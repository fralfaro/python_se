{"config":{"lang":["es"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"\ud83d\udc68\u200d\ud83d\udcbb Bienvenido a Python Software Engineering","text":""},{"location":"#contenidos-del-curso","title":"\ud83d\udcda Contenidos del Curso","text":"<p>Fundamentos</p><p>Convenciones, paradigmas de programaci\u00f3n, funciones, clases y tipado est\u00e1tico.</p> <p>Dise\u00f1o de Software</p><p>Principios S.O.L.I.D., patrones de dise\u00f1o, refactorizaci\u00f3n y estructura de proyectos.</p> <p>Control de Versiones</p><p>Git, GitHub, gitignore y licencias para proyectos colaborativos.</p> <p>Entornos y Dependencias</p><p>Pyenv, Virtualenv, Poetry, uv y Makefile para entornos reproducibles.</p> <p>Calidad de C\u00f3digo</p><p>Ruff, linters, pre-commit, Black y Mypy para mantener c\u00f3digo limpio y estable.</p> <p>Testing</p><p>Pytest, Coverage, Mocking e Hypothesis para asegurar el comportamiento correcto del software.</p> <p>Documentaci\u00f3n</p><p>Aprende a documentar profesionalmente con MkDocs, Material y plugins \u00fatiles.</p> <p>Extras</p><p>Diagramas con PlantUML, herramientas visuales y notebooks interactivos.</p>"},{"location":"unit1/","title":"\ud83d\udcd6 Fundamentos de Python Profesional","text":"<p>La Unidad 1 sienta las bases esenciales para escribir c\u00f3digo profesional en Python. Aqu\u00ed no solo aprender\u00e1s a programar, sino a hacerlo bien: con claridad, estructura, validaci\u00f3n y estilo. Estas herramientas y conceptos ser\u00e1n fundamentales para desarrollar software robusto y mantenible a lo largo del curso.</p>"},{"location":"unit1/#objetivos-de-la-unidad","title":"\ud83c\udfaf Objetivos de la unidad","text":"<ul> <li>Comprender la filosof\u00eda y estilo de codificaci\u00f3n en Python.</li> <li>Organizar correctamente scripts y proyectos.</li> <li>Reconocer los distintos paradigmas de programaci\u00f3n y aplicarlos.</li> <li>Definir funciones y clases de forma idiom\u00e1tica y modular.</li> <li>Usar tipado est\u00e1tico y validaci\u00f3n de datos en c\u00f3digo moderno.</li> <li>Adoptar una mentalidad Pythonic para escribir c\u00f3digo claro y expresivo.</li> </ul>"},{"location":"unit1/#contenidos","title":"\ud83e\udded Contenidos","text":"Tema Descripci\u00f3n breve \ud83d\udccf Convenciones y Estilo (PEP 8) Aprende las reglas de estilo para escribir c\u00f3digo legible y mantenible. \u2699\ufe0f Ejecuci\u00f3n, Imports y Scripts C\u00f3mo organizar tus archivos, ejecutar scripts y entender el flujo principal. \ud83e\udde0 Paradigmas de Programaci\u00f3n Diferencias entre programaci\u00f3n imperativa, funcional y orientada a objetos. \ud83d\udee0\ufe0f Funciones Uso correcto de funciones, par\u00e1metros, retorno y <code>lambda</code>. \ud83e\uddf1 Clases Creaci\u00f3n de objetos, atributos, m\u00e9todos y principios b\u00e1sicos de OOP. \ud83d\udd12 Tipado Est\u00e1tico Introducci\u00f3n al sistema de tipos en Python con <code>typing</code>. \u2705 Validaci\u00f3n con Pydantic C\u00f3mo validar datos f\u00e1cilmente usando clases con anotaciones de tipo. \u2728 Pensamiento Pythonic Filosof\u00eda de escritura limpia, idiom\u00e1tica y profesional en Python."},{"location":"unit1/#recomendacion","title":"\ud83e\udde0 Recomendaci\u00f3n","text":"<p>Te recomendamos avanzar en el orden propuesto para construir tu conocimiento progresivamente, desde el estilo y la ejecuci\u00f3n, hasta los conceptos m\u00e1s potentes como tipado est\u00e1tico y validaci\u00f3n.</p> <p>No es necesario memorizar todo: lo importante es entender cu\u00e1ndo usar cada herramienta y por qu\u00e9.</p>"},{"location":"unit1/#prerrequisitos","title":"\ud83d\udcda Prerrequisitos","text":"<ul> <li>Conocimientos b\u00e1sicos de Python (variables, condicionales, bucles)</li> <li>Entorno de desarrollo configurado (VS Code, Jupyter o similar)</li> <li>Curiosidad por escribir mejor c\u00f3digo \ud83d\ude09</li> </ul>"},{"location":"unit1/#que-lograras-al-finalizar-esta-unidad","title":"\u2705 \u00bfQu\u00e9 lograr\u00e1s al finalizar esta unidad?","text":"<ul> <li>Escribir scripts Python bien estructurados y legibles.</li> <li>Pensar y resolver problemas usando diferentes paradigmas.</li> <li>Crear funciones y clases limpias, tipadas y validables.</li> <li>Prepararte para aplicar buenas pr\u00e1cticas de dise\u00f1o en proyectos reales.</li> </ul>"},{"location":"unit1/classes/","title":"Clases en Python","text":""},{"location":"unit1/classes/#introduccion","title":"Introducci\u00f3n","text":"<p>La programaci\u00f3n orientada a objetos (OOP) es un paradigma ampliamente utilizado para modelar sistemas complejos y estructurar el c\u00f3digo en componentes reutilizables. En Python, las clases permiten encapsular datos y comportamientos relacionados en una sola entidad: el objeto.</p> <p>Este cap\u00edtulo te introducir\u00e1 a las clases en Python, cubriendo desde los conceptos fundamentales hasta pr\u00e1cticas avanzadas como herencia, m\u00e9todos especiales y anotaciones. Ver\u00e1s c\u00f3mo estructurar tu c\u00f3digo de forma m\u00e1s mantenible, reutilizable y expresiva mediante clases.</p>"},{"location":"unit1/classes/#que-es-una-clase","title":"\u00bfQu\u00e9 es una clase?","text":"<p>Una clase es una plantilla para crear objetos. Define atributos (datos) y m\u00e9todos (funciones) que describen el comportamiento de los objetos.</p>"},{"location":"unit1/classes/#ejemplo-simple","title":"Ejemplo simple","text":"<pre><code>class Persona:\n    def __init__(self, nombre):\n        self.nombre = nombre\n\n    def saludar(self):\n        return f\"Hola, soy {self.nombre}\"\n\np = Persona(\"Francisco\")\nprint(p.saludar())  # Hola, soy Francisco\n</code></pre>"},{"location":"unit1/classes/#estructura-basica-de-una-clase","title":"Estructura b\u00e1sica de una clase","text":"<pre><code>class NombreClase:\n    def __init__(self, parametros):\n        self.atributo = valor\n\n    def metodo(self):\n        # comportamiento\n        pass\n</code></pre>"},{"location":"unit1/classes/#componentes-clave","title":"Componentes clave","text":"<ul> <li><code>class</code>: palabra clave para definir una clase.</li> <li><code>__init__</code>: m\u00e9todo constructor, se ejecuta al crear un nuevo objeto.</li> <li><code>self</code>: referencia al objeto actual.</li> <li>M\u00e9todos: funciones definidas dentro de una clase que operan sobre sus atributos.</li> </ul>"},{"location":"unit1/classes/#atributos-de-instancia-vs-de-clase","title":"Atributos: de instancia vs de clase","text":""},{"location":"unit1/classes/#atributos-de-instancia","title":"Atributos de instancia","text":"<p>Se definen en el constructor (<code>__init__</code>) y son \u00fanicos para cada objeto.</p> <pre><code>class Vehiculo:\n    def __init__(self, color):\n        self.color = color\n</code></pre>"},{"location":"unit1/classes/#atributos-de-clase","title":"Atributos de clase","text":"<p>Son compartidos por todas las instancias.</p> <pre><code>class Vehiculo:\n    ruedas = 4  # atributo de clase\n\n    def __init__(self, color):\n        self.color = color\n</code></pre>"},{"location":"unit1/classes/#metodos-especiales","title":"M\u00e9todos especiales","text":"<p>Python permite personalizar el comportamiento de los objetos usando m\u00e9todos especiales (<code>__dunder__</code>).</p> M\u00e9todo Funci\u00f3n <code>__init__</code> Constructor del objeto <code>__str__</code> Representaci\u00f3n amigable (<code>str(obj)</code>) <code>__repr__</code> Representaci\u00f3n t\u00e9cnica (<code>repr(obj)</code>) <code>__eq__</code> Comparaci\u00f3n de igualdad (<code>==</code>) <pre><code>class Producto:\n    def __init__(self, nombre, precio):\n        self.nombre = nombre\n        self.precio = precio\n\n    def __str__(self):\n        return f\"{self.nombre} - ${self.precio}\"\n</code></pre>"},{"location":"unit1/classes/#metodos-de-clase-y-estaticos","title":"M\u00e9todos de clase y est\u00e1ticos","text":""},{"location":"unit1/classes/#classmethod","title":"<code>@classmethod</code>","text":"<p>Accede a la clase en lugar de a la instancia.</p> <pre><code>class Usuario:\n    usuarios = []\n\n    def __init__(self, nombre):\n        self.nombre = nombre\n        Usuario.usuarios.append(self)\n\n    @classmethod\n    def total_usuarios(cls):\n        return len(cls.usuarios)\n</code></pre>"},{"location":"unit1/classes/#staticmethod","title":"<code>@staticmethod</code>","text":"<p>No accede ni a la clase ni a la instancia. Es como una funci\u00f3n normal dentro del namespace de la clase.</p> <pre><code>class Calculadora:\n    @staticmethod\n    def sumar(x, y):\n        return x + y\n</code></pre>"},{"location":"unit1/classes/#herencia-y-polimorfismo","title":"Herencia y polimorfismo","text":"<p>Python permite que una clase herede atributos y m\u00e9todos de otra, lo que promueve la reutilizaci\u00f3n y extensi\u00f3n del c\u00f3digo.</p> <pre><code>class Animal:\n    def hablar(self):\n        return \"Hace un sonido\"\n\nclass Perro(Animal):\n    def hablar(self):\n        return \"Ladra\"\n\np = Perro()\nprint(p.hablar())  # Ladra\n</code></pre> <p>\ud83e\udde0 Esto es polimorfismo: el mismo m\u00e9todo (<code>hablar</code>) se comporta diferente seg\u00fan la clase.</p>"},{"location":"unit1/classes/#buenas-practicas","title":"Buenas pr\u00e1cticas","text":"<p>\u2705 Usa nombres en <code>PascalCase</code> para clases \u2705 Define solo lo necesario en <code>__init__</code> \u2705 A\u00f1ade <code>__str__</code> para una representaci\u00f3n legible \u2705 Prefiere <code>@classmethod</code> cuando necesites modificar atributos de clase \u2705 Aplica herencia solo si hay una verdadera relaci\u00f3n jer\u00e1rquica</p>"},{"location":"unit1/classes/#errores-comunes","title":"Errores comunes","text":"<p>\u274c Olvidar el uso de <code>self</code> en m\u00e9todos de instancia \u274c Redefinir atributos de clase desde instancias sin intenci\u00f3n \u274c Crear jerarqu\u00edas de herencia profundas e innecesarias \u274c Sobrecargar <code>__init__</code> con demasiada l\u00f3gica</p>"},{"location":"unit1/classes/#recursos-utiles","title":"Recursos \u00fatiles","text":"<ul> <li>\ud83d\udcd8 Clases \u2013 Tutorial oficial de Python</li> <li>\ud83e\uddf0 PEP 8 \u2013 Nombres de clases y m\u00e9todos</li> <li>\ud83d\udcda Fluent Python \u2013 Cap\u00edtulos sobre clases y objetos avanzados</li> </ul>"},{"location":"unit1/classes/#conclusion","title":"Conclusi\u00f3n","text":"<p>Las clases son una herramienta poderosa en Python para modelar estructuras complejas del mundo real. Entender su sintaxis y principios te permitir\u00e1 construir software m\u00e1s organizado, extensible y orientado a objetos.</p> <p>Dominar las clases es un paso fundamental hacia el desarrollo de aplicaciones robustas y bien estructuradas en Python.</p>"},{"location":"unit1/function/","title":"Funciones en Python","text":""},{"location":"unit1/function/#introduccion","title":"Introducci\u00f3n","text":"<p>Las funciones son bloques fundamentales de construcci\u00f3n en Python. Permiten encapsular l\u00f3gica reutilizable, estructurar el c\u00f3digo y mejorar su claridad. Desde simples scripts hasta aplicaciones complejas, el uso efectivo de funciones marca la diferencia entre c\u00f3digo improvisado y software profesional.</p> <p>En este cap\u00edtulo exploraremos la definici\u00f3n, uso y buenas pr\u00e1cticas en torno a las funciones en Python, incluyendo funciones an\u00f3nimas, de orden superior y mecanismos avanzados como <code>*args</code> y <code>**kwargs</code>.</p>"},{"location":"unit1/function/#que-es-una-funcion","title":"\u00bfQu\u00e9 es una funci\u00f3n?","text":"<p>Una funci\u00f3n es un bloque de c\u00f3digo que realiza una tarea espec\u00edfica. Se puede invocar (llamar) m\u00faltiples veces y permite pasarle entradas (argumentos) y obtener una salida (retorno).</p>"},{"location":"unit1/function/#ejemplo-basico","title":"Ejemplo b\u00e1sico","text":"<pre><code>def saludar(nombre):\n    return f\"Hola, {nombre}!\"\n</code></pre> <pre><code>print(saludar(\"Francisco\"))  # Hola, Francisco!\n</code></pre>"},{"location":"unit1/function/#sintaxis-y-estructura-de-funciones","title":"Sintaxis y estructura de funciones","text":"<pre><code>def nombre_funcion(param1, param2=valor_por_defecto):\n    \"\"\"Docstring: breve descripci\u00f3n de lo que hace la funci\u00f3n.\"\"\"\n    # Cuerpo de la funci\u00f3n\n    return resultado\n</code></pre>"},{"location":"unit1/function/#elementos-clave","title":"Elementos clave:","text":"<ul> <li><code>def</code>: palabra clave para definir una funci\u00f3n.</li> <li><code>nombre_funcion</code>: identificador que usaremos para llamarla.</li> <li><code>parametros</code>: entradas que puede recibir.</li> <li><code>return</code>: valor que devuelve (puede ser omitido).</li> <li><code>docstring</code>: comentario opcional que documenta la funci\u00f3n.</li> </ul>"},{"location":"unit1/function/#tipos-de-funciones-en-python","title":"Tipos de funciones en Python","text":""},{"location":"unit1/function/#1-funciones-definidas-por-el-usuario","title":"1. Funciones definidas por el usuario","text":"<p>Estas son funciones comunes que definimos con <code>def</code>.</p> <pre><code>def sumar(a, b):\n    return a + b\n</code></pre>"},{"location":"unit1/function/#2-funciones-anonimas-lambda","title":"2. Funciones an\u00f3nimas (lambda)","text":"<p>Permiten definir funciones peque\u00f1as en una sola l\u00ednea, sin nombre.</p> <pre><code>cuadrado = lambda x: x ** 2\nprint(cuadrado(4))  # 16\n</code></pre> <p>\u26a0\ufe0f Las funciones <code>lambda</code> son \u00fatiles para casos simples. No reemplazan a las funciones completas con <code>def</code>.</p>"},{"location":"unit1/function/#3-funciones-de-orden-superior","title":"3. Funciones de orden superior","text":"<p>Son funciones que aceptan otras funciones como argumentos o devuelven funciones.</p> <pre><code>def aplicar(funcion, lista):\n    return [funcion(x) for x in lista]\n\nresultado = aplicar(lambda x: x * 2, [1, 2, 3])\nprint(resultado)  # [2, 4, 6]\n</code></pre>"},{"location":"unit1/function/#parametros-y-retorno","title":"Par\u00e1metros y retorno","text":"<p>Python ofrece mucha flexibilidad para manejar argumentos:</p> Tipo de par\u00e1metro Ejemplo Descripci\u00f3n Posicional <code>def f(x, y)</code> Se pasan en orden Nombrado <code>f(x=10, y=20)</code> Se pasan con nombre expl\u00edcito Por defecto <code>def f(x=5)</code> Si no se pasa, se usa el valor por defecto <code>*args</code> <code>def f(*args)</code> Recibe m\u00faltiples argumentos posicionales <code>**kwargs</code> <code>def f(**kwargs)</code> Recibe m\u00faltiples argumentos nombrados"},{"location":"unit1/function/#ejemplo-combinado","title":"Ejemplo combinado","text":"<pre><code>def resumen(nombre, *actividades, **extras):\n    print(f\"Nombre: {nombre}\")\n    print(\"Actividades:\", actividades)\n    print(\"Extras:\", extras)\n\nresumen(\"Francisco\", \"Python\", \"Git\", nivel=\"intermedio\", pais=\"Chile\")\n</code></pre>"},{"location":"unit1/function/#tipado-de-funciones-type-hints","title":"Tipado de funciones (Type Hints)","text":"<p>Las anotaciones de tipo ayudan a documentar el comportamiento esperado de una funci\u00f3n:</p> <pre><code>def multiplicar(x: int, y: int) -&gt; int:\n    return x * y\n</code></pre> <p>Estas anotaciones no son obligatorias, pero mejoran la claridad y permiten el uso de herramientas como <code>mypy</code>.</p>"},{"location":"unit1/function/#buenas-practicas","title":"Buenas pr\u00e1cticas","text":"<p>\u2705 Nombra tus funciones con verbos descriptivos (<code>obtener_datos</code>, <code>calcular_total</code>) \u2705 Mant\u00e9n las funciones peque\u00f1as y enfocadas en una sola tarea \u2705 Usa docstrings claros \u2705 A\u00f1ade anotaciones de tipo cuando sea posible \u2705 Prefiere <code>def</code> sobre <code>lambda</code> si la l\u00f3gica es compleja</p>"},{"location":"unit1/function/#errores-comunes","title":"Errores comunes","text":"<p>\u274c No retornar nada cuando se espera un valor \u274c Tener demasiados efectos secundarios dentro de una funci\u00f3n \u274c Usar variables globales sin necesidad \u274c Usar <code>lambda</code> para l\u00f3gica compleja (dificulta la lectura)</p>"},{"location":"unit1/function/#referencias-utiles","title":"Referencias \u00fatiles","text":"<ul> <li>\ud83d\udcd8 Funciones \u2013 Tutorial oficial de Python</li> <li>\ud83e\uddf0 PEP 8 \u2013 Nombres de funciones</li> <li>\ud83e\uddea PEP 484 \u2013 Type Hints</li> </ul>"},{"location":"unit1/function/#conclusion","title":"Conclusi\u00f3n","text":"<p>Las funciones son esenciales para crear c\u00f3digo modular y reutilizable. Usarlas correctamente mejora la organizaci\u00f3n del programa y facilita su mantenimiento. Python ofrece muchas herramientas para definir funciones de forma clara, concisa y expresiva, desde funciones simples hasta patrones m\u00e1s avanzados como funciones de orden superior o tipado est\u00e1tico.</p> <p>Dominar este componente es clave en la transici\u00f3n de escribir scripts improvisados a desarrollar software profesional.</p>"},{"location":"unit1/paradigm/","title":"Paradigmas de programaci\u00f3n","text":""},{"location":"unit1/paradigm/#introduccion","title":"Introducci\u00f3n","text":"<p>En el desarrollo de software, existen m\u00faltiples formas de organizar y estructurar el c\u00f3digo. Estas formas se conocen como paradigmas de programaci\u00f3n, y cada uno ofrece una manera distinta de pensar y resolver problemas. Python es un lenguaje multiparadigma, lo que significa que admite varios enfoques, permiti\u00e9ndonos elegir la mejor estrategia seg\u00fan el contexto del proyecto.</p> <p>Comprender los distintos paradigmas es fundamental para escribir c\u00f3digo m\u00e1s expresivo, modular y mantenible. Este cap\u00edtulo presenta los principales paradigmas compatibles con Python, sus caracter\u00edsticas distintivas y c\u00f3mo implementarlos de forma efectiva.</p>"},{"location":"unit1/paradigm/#que-es-un-paradigma-de-programacion","title":"\u00bfQu\u00e9 es un paradigma de programaci\u00f3n?","text":"<p>Un paradigma de programaci\u00f3n es un modelo o estilo de programaci\u00f3n que define c\u00f3mo se estructuran y ejecutan las instrucciones en un lenguaje. Influye en c\u00f3mo pensamos los problemas, dise\u00f1amos las soluciones y escribimos el c\u00f3digo.</p> <p>Cada paradigma tiene sus propias reglas, estructuras y formas de abstraer el comportamiento del programa. Python, al ser flexible, permite adoptar varios de estos estilos en un mismo proyecto, aunque hacerlo sin criterio puede llevar a una mezcla confusa y dif\u00edcil de mantener.</p>"},{"location":"unit1/paradigm/#principales-paradigmas-en-python","title":"Principales paradigmas en Python","text":""},{"location":"unit1/paradigm/#1-programacion-imperativa","title":"1. Programaci\u00f3n Imperativa","text":"<p>La programaci\u00f3n imperativa se basa en dar instrucciones paso a paso para modificar el estado del programa. Es el paradigma m\u00e1s cercano a c\u00f3mo funcionan los computadores internamente.</p>"},{"location":"unit1/paradigm/#caracteristicas","title":"Caracter\u00edsticas","text":"<ul> <li>Uso expl\u00edcito de variables y estructuras de control (<code>for</code>, <code>if</code>, <code>while</code>)</li> <li>\u00c9nfasis en c\u00f3mo hacer las cosas (secuencia de acciones)</li> <li>Cambios de estado mutables</li> </ul>"},{"location":"unit1/paradigm/#ejemplo-en-python","title":"Ejemplo en Python","text":"<pre><code>numbers = [1, 2, 3, 4, 5]\nsquared = []\n\nfor n in numbers:\n    squared.append(n * n)\n\nprint(squared)\n</code></pre>"},{"location":"unit1/paradigm/#2-programacion-funcional","title":"2. Programaci\u00f3n Funcional","text":"<p>La programaci\u00f3n funcional trata a las funciones como ciudadanos de primera clase y evita cambios de estado. Favorece el uso de expresiones puras y operaciones inmutables.</p>"},{"location":"unit1/paradigm/#caracteristicas_1","title":"Caracter\u00edsticas","text":"<ul> <li>Uso de funciones puras (sin efectos colaterales)</li> <li>Uso de <code>map</code>, <code>filter</code>, <code>reduce</code>, y comprensiones</li> <li>Enfoque declarativo: se describe qu\u00e9 hacer, no c\u00f3mo</li> </ul>"},{"location":"unit1/paradigm/#ejemplo-en-python_1","title":"Ejemplo en Python","text":"<pre><code>numbers = [1, 2, 3, 4, 5]\nsquared = list(map(lambda x: x * x, numbers))\nprint(squared)\n</code></pre> <p>\ud83d\udca1 Python no es un lenguaje funcional puro, pero soporta muchos elementos funcionales.</p>"},{"location":"unit1/paradigm/#3-programacion-orientada-a-objetos-oop","title":"3. Programaci\u00f3n Orientada a Objetos (OOP)","text":"<p>La OOP organiza el c\u00f3digo en torno a objetos que combinan datos y comportamiento. Es \u00fatil para modelar sistemas complejos y reutilizables.</p>"},{"location":"unit1/paradigm/#caracteristicas_2","title":"Caracter\u00edsticas","text":"<ul> <li>Uso de clases y objetos</li> <li>Encapsulamiento, herencia y polimorfismo</li> <li>Agrupaci\u00f3n de datos y funciones relacionadas</li> </ul>"},{"location":"unit1/paradigm/#ejemplo-en-python_2","title":"Ejemplo en Python","text":"<pre><code>class SquareCalculator:\n    def __init__(self, numbers):\n        self.numbers = numbers\n\n    def square_all(self):\n        return [n * n for n in self.numbers]\n\ncalc = SquareCalculator([1, 2, 3, 4, 5])\nprint(calc.square_all())\n</code></pre>"},{"location":"unit1/paradigm/#comparacion-entre-paradigmas","title":"Comparaci\u00f3n entre paradigmas","text":"Caracter\u00edstica Imperativo Funcional Orientado a Objetos Enfoque Secuencia de pasos Evaluaci\u00f3n de funciones Modelado con objetos Estado Mutable Inmutable Mutable o encapsulado Composici\u00f3n Instrucciones Funciones Clases y m\u00e9todos Claridad Alta (procedimientos simples) Alta (operaciones declarativas) Alta (modelos complejos) Ideal para Algoritmos b\u00e1sicos Transformaciones de datos Sistemas modulares y extensibles"},{"location":"unit1/paradigm/#buenas-practicas","title":"Buenas pr\u00e1cticas","text":"<ul> <li>\u2705 Elige el paradigma adecuado seg\u00fan el problema. No todos los problemas necesitan clases; algunos se resuelven con funciones puras.</li> <li>\u2705 En proyectos grandes, define un estilo dominante para evitar mezclas ca\u00f3ticas.</li> <li>\u2705 Usa comprensi\u00f3n de listas (<code>[x for x in iterable]</code>) y generadores como forma limpia y eficiente de aplicar estilo funcional en Python.</li> <li>\u2705 Refactoriza c\u00f3digo imperativo a funcional cuando busques mayor expresividad o menor mutabilidad.</li> </ul>"},{"location":"unit1/paradigm/#errores-comunes","title":"Errores comunes","text":"<ul> <li>\u274c Mezclar paradigmas sin estructura clara.</li> <li>\u274c Usar programaci\u00f3n orientada a objetos para problemas que solo requieren funciones simples.</li> <li>\u274c Aplicar funciones lambda complejas que afectan la legibilidad.</li> <li>\u274c Abusar del estado global en estilos imperativos.</li> </ul>"},{"location":"unit1/paradigm/#recursos-recomendados","title":"Recursos recomendados","text":"<ul> <li>\ud83d\udcc4 PEP 8 \u2013 Gu\u00eda de estilo Python</li> <li>\ud83d\udcd8 Functional Programming HOWTO \u2013 Python Docs</li> <li>\ud83d\udcd8 Object-Oriented Programming \u2013 Python Docs</li> <li>\ud83d\udcda Fluent Python, Luciano Ramalho \u2013 Cap\u00edtulos sobre estilos funcional y orientado a objetos.</li> </ul>"},{"location":"unit1/paradigm/#conclusion","title":"Conclusi\u00f3n","text":"<p>Python es un lenguaje vers\u00e1til que permite programar de muchas formas. Conocer y dominar los distintos paradigmas te permite escribir c\u00f3digo m\u00e1s expresivo, modular y adecuado a cada tipo de problema.</p> <p>En vez de adoptar un \u00fanico paradigma r\u00edgidamente, aprende a combinar los estilos con intenci\u00f3n y claridad. Ser consciente del paradigma que est\u00e1s usando \u2014y por qu\u00e9\u2014 es una de las se\u00f1ales m\u00e1s claras de madurez como desarrollador Python.</p>"},{"location":"unit1/pep/","title":"Convenciones y Estilo (PEP 8)","text":""},{"location":"unit1/pep/#introduccion","title":"Introducci\u00f3n","text":"<p>En el mundo del desarrollo de software, seguir convenciones no es simplemente una cuesti\u00f3n de estilo: es una pr\u00e1ctica fundamental que mejora la legibilidad, mantenibilidad y colaboraci\u00f3n dentro de los proyectos. En Python, estas convenciones est\u00e1n formalizadas a trav\u00e9s de las PEPs (Python Enhancement Proposals), una colecci\u00f3n de documentos que definen tanto aspectos t\u00e9cnicos del lenguaje como sus pr\u00e1cticas de uso.</p> <p>Dentro de este conjunto, la PEP 8 se ha convertido en la gu\u00eda de estilo por excelencia para escribir c\u00f3digo Python limpio y legible. Comprender qu\u00e9 son las PEPs y por qu\u00e9 es tan importante adherirse a convenciones como la PEP 8 es el primer paso para escribir software profesional en Python.</p>"},{"location":"unit1/pep/#que-es-una-pep","title":"\u00bfQu\u00e9 es una PEP?","text":"<p>Una PEP (Python Enhancement Proposal) es un documento oficial que propone nuevas funcionalidades, cambios o mejoras en el lenguaje Python, su est\u00e1ndar de biblioteca o sus procesos de desarrollo. Son propuestas p\u00fablicas que se discuten, eval\u00faan y, en muchos casos, adoptan como parte del desarrollo oficial del lenguaje.</p> <p>Las PEPs pueden clasificarse en tres tipos principales:</p> Tipo de PEP Descripci\u00f3n Est\u00e1ndar Proponen cambios en la sintaxis o comportamiento de Python. Informativas Documentan buenas pr\u00e1cticas y convenciones aceptadas por la comunidad. De proceso Describen aspectos organizativos del desarrollo de Python. <p>Algunos ejemplos notables:</p> <ul> <li>\ud83d\udcdc PEP 8: Gu\u00eda de estilo para el c\u00f3digo Python.</li> <li>\ud83e\udde0 PEP 20: The Zen of Python, una colecci\u00f3n de aforismos sobre la filosof\u00eda del lenguaje.</li> <li>\ud83d\udd12 PEP 484: Introducci\u00f3n del tipado est\u00e1tico en Python con anotaciones.</li> </ul> <p>\ud83d\udcce Nota: Todas las PEPs est\u00e1n disponibles en el sitio oficial: https://peps.python.org</p>"},{"location":"unit1/pep/#la-pep-8-y-la-importancia-del-estilo","title":"La PEP 8 y la importancia del estilo","text":"<p>La PEP 8 es una de las PEPs m\u00e1s influyentes. Define un conjunto de reglas de estilo para escribir c\u00f3digo Python de forma clara, coherente y profesional. Aunque el int\u00e9rprete de Python no obliga a seguir estas reglas, su adopci\u00f3n generalizada ha generado un idioma com\u00fan entre los desarrolladores Python en todo el mundo.</p>"},{"location":"unit1/pep/#por-que-seguir-la-pep-8","title":"\u00bfPor qu\u00e9 seguir la PEP 8?","text":"<ul> <li>\u2705 Legibilidad: El c\u00f3digo limpio y consistente es m\u00e1s f\u00e1cil de leer y entender.</li> <li>\ud83e\udd1d Colaboraci\u00f3n: Cuando todos siguen el mismo estilo, se minimizan conflictos y malentendidos en equipos de trabajo.</li> <li>\ud83d\udee0\ufe0f Herramientas compatibles: Muchas herramientas como <code>black</code>, <code>ruff</code>, <code>flake8</code> o incluso editores como VS Code est\u00e1n dise\u00f1adas para trabajar con estas convenciones.</li> <li>\ud83d\udcc8 Mantenibilidad: El c\u00f3digo bien estructurado es m\u00e1s f\u00e1cil de mantener, refactorizar y extender con el tiempo.</li> </ul>"},{"location":"unit1/pep/#ejemplos-practicos-malas-y-buenas-practicas-segun-pep-8","title":"Ejemplos pr\u00e1cticos: Malas y buenas pr\u00e1cticas seg\u00fan PEP 8","text":""},{"location":"unit1/pep/#codigo-que-no-sigue-pep-8","title":"\u274c C\u00f3digo que no sigue PEP 8","text":"<pre><code>def add(x,y):return x+y\nclassmath:pass\n</code></pre> <ul> <li>No hay espacios despu\u00e9s de las comas.</li> <li>La funci\u00f3n est\u00e1 en una sola l\u00ednea sin claridad.</li> <li>El nombre de la clase no est\u00e1 en formato <code>PascalCase</code>.</li> <li>Falta un bloque <code>body</code> en la clase.</li> </ul>"},{"location":"unit1/pep/#codigo-que-sigue-pep-8","title":"\u2705 C\u00f3digo que sigue PEP 8","text":"<pre><code>class Math:\n    def add(self, x, y):\n        return x + y\n</code></pre> <ul> <li>La clase est\u00e1 correctamente capitalizada (<code>PascalCase</code>).</li> <li>La funci\u00f3n tiene espacios adecuados y cada instrucci\u00f3n en su propia l\u00ednea.</li> <li>El bloque <code>body</code> est\u00e1 correctamente indentado (4 espacios).</li> </ul>"},{"location":"unit1/pep/#recomendaciones-practicas","title":"Recomendaciones pr\u00e1cticas","text":""},{"location":"unit1/pep/#buenas-practicas","title":"Buenas pr\u00e1cticas","text":"<ul> <li>Usa 4 espacios por nivel de indentaci\u00f3n (nunca tabulaciones).</li> <li>Limita la longitud de l\u00ednea a 79 caracteres.</li> <li>Nombra tus variables, funciones y clases de manera descriptiva:<ul> <li><code>snake_case</code> para variables y funciones.</li> <li><code>PascalCase</code> para clases.</li> <li><code>UPPER_CASE</code> para constantes.</li> </ul> </li> </ul>"},{"location":"unit1/pep/#errores-comunes","title":"Errores comunes","text":"<ul> <li>Escribir todo en una l\u00ednea por brevedad (perdiendo claridad).</li> <li>No dejar espacios alrededor de operadores.</li> <li>Ignorar la consistencia entre m\u00f3dulos y funciones.</li> <li>Usar nombres gen\u00e9ricos como <code>x</code>, <code>data</code>, <code>temp</code> en exceso.</li> </ul>"},{"location":"unit1/pep/#herramientas-para-seguir-pep-8-automaticamente","title":"Herramientas para seguir PEP 8 autom\u00e1ticamente","text":"<p>Utilizar herramientas de an\u00e1lisis y formateo puede ayudarte a mantener el estilo sin esfuerzo manual.</p> Herramienta Funcionalidad Instalaci\u00f3n black Formateador autom\u00e1tico de c\u00f3digo <code>pip install black</code> ruff Linter + formateador ultrarr\u00e1pido <code>pip install ruff</code> flake8 Linter tradicional basado en PEP 8 <code>pip install flake8</code>"},{"location":"unit1/pep/#ejemplo-de-uso-con-black","title":"Ejemplo de uso con <code>black</code>","text":"<pre><code>black archivo.py\n</code></pre> <p>Esto reescribir\u00e1 tu archivo <code>archivo.py</code> con formato est\u00e1ndar basado en PEP 8.</p>"},{"location":"unit1/pep/#como-configurar-tu-editor","title":"C\u00f3mo configurar tu editor","text":""},{"location":"unit1/pep/#visual-studio-code-vs-code","title":"Visual Studio Code (VS Code)","text":"<ol> <li>Instala las extensiones:<ul> <li>Python (Microsoft)</li> <li>Black Formatter</li> <li>Ruff</li> </ul> </li> <li>A\u00f1ade a tu configuraci\u00f3n (<code>settings.json</code>):</li> </ol> <pre><code>{\n  \"editor.formatOnSave\": true,\n  \"python.formatting.provider\": \"black\",\n  \"python.linting.ruffEnabled\": true,\n  \"editor.codeActionsOnSave\": {\n    \"source.fixAll\": true\n  }\n}\n</code></pre>"},{"location":"unit1/pep/#pycharm","title":"PyCharm","text":"<ol> <li>Habilita el an\u00e1lisis de estilo en Settings &gt; Code Style &gt; Python.</li> <li>Integra <code>black</code> y <code>flake8</code> desde External Tools.</li> </ol>"},{"location":"unit1/pep/#referencias-utiles","title":"Referencias \u00fatiles","text":"<ul> <li>\ud83d\udcdd PEP 8 \u2013 Style Guide for Python Code</li> <li>\ud83d\udcda PEP Index oficial</li> <li>\u2699\ufe0f Black \u2013 The Uncompromising Code Formatter</li> <li>\ud83d\ude80 Ruff \u2013 Fast Python linter &amp; formatter</li> <li>\ud83e\uddea Flake8 \u2013 Python style guide enforcement</li> </ul>"},{"location":"unit1/pep/#conclusion","title":"Conclusi\u00f3n","text":"<p>Las PEPs son una piedra angular del ecosistema Python, y en particular, la PEP 8 ha sido clave para establecer una cultura de c\u00f3digo limpio, legible y mantenible. Adoptar estas convenciones no es solo una cuesti\u00f3n de estilo, sino un compromiso con la calidad y la colaboraci\u00f3n profesional.</p> <p>Integrar estas pr\u00e1cticas desde el inicio no solo facilitar\u00e1 tu trabajo, sino que tambi\u00e9n te abrir\u00e1 las puertas a participar eficazmente en equipos, contribuir en proyectos open source y desarrollar software que perdure y escale.</p>"},{"location":"unit1/pydantic/","title":"Validaci\u00f3n moderna - Pydantic","text":""},{"location":"unit1/pydantic/#introduccion","title":"Introducci\u00f3n","text":"<p>Una de las grandes ventajas de Python moderno es su capacidad para trabajar con datos estructurados y validados sin perder legibilidad. Cuando se combinan type hints con validaci\u00f3n autom\u00e1tica, el desarrollo se vuelve m\u00e1s robusto y confiable. Aqu\u00ed entra Pydantic, una biblioteca que convierte modelos de datos basados en clases en potentes herramientas de validaci\u00f3n, serializaci\u00f3n y parsing, todo usando anotaciones de tipo est\u00e1ndar.</p> <p>Este cap\u00edtulo introduce el uso de Pydantic en proyectos reales, explicando c\u00f3mo crear modelos, validar entradas y aprovechar las ventajas del tipado est\u00e1tico para trabajar con datos externos.</p>"},{"location":"unit1/pydantic/#que-es-pydantic","title":"\u00bfQu\u00e9 es Pydantic?","text":"<p>Pydantic es una biblioteca que permite definir y validar datos usando clases y anotaciones de tipo est\u00e1ndar de Python (<code>str</code>, <code>int</code>, <code>float</code>, <code>list</code>, etc.). Es ampliamente usada en frameworks como FastAPI, pero tambi\u00e9n es \u00fatil en cualquier aplicaci\u00f3n que consuma datos de fuentes externas (APIs, formularios, archivos de configuraci\u00f3n, etc.).</p> <p>Caracter\u00edsticas clave:</p> <ul> <li>Validaci\u00f3n autom\u00e1tica de tipos al crear instancias.</li> <li>Conversi\u00f3n (parsing) de tipos cuando es posible.</li> <li>Generaci\u00f3n autom\u00e1tica de esquemas JSON y documentaci\u00f3n.</li> </ul>"},{"location":"unit1/pydantic/#instalacion","title":"Instalaci\u00f3n","text":"<pre><code>pip install pydantic\n</code></pre> <p>Si usas Python 3.10+, puedes instalar Pydantic v2: <code>pip install \"pydantic&gt;=2.0\"</code></p> <p>Para este cap\u00edtulo se usan ejemplos de Pydantic 1.10+, compatible con FastAPI y ampliamente adoptado.</p>"},{"location":"unit1/pydantic/#definiendo-modelos-con-pydantic","title":"Definiendo modelos con Pydantic","text":"<pre><code>from pydantic import BaseModel\n\nclass Usuario(BaseModel):\n    nombre: str\n    edad: int\n    activo: bool = True\n</code></pre> <pre><code>u = Usuario(nombre=\"Ana\", edad=\"30\")\nprint(u.edad)  # 30 (conversi\u00f3n autom\u00e1tica de str a int)\n</code></pre>"},{"location":"unit1/pydantic/#ventajas","title":"Ventajas:","text":"<ul> <li>Tipado expl\u00edcito y validaci\u00f3n inmediata.</li> <li>Conversi\u00f3n autom\u00e1tica cuando el tipo es compatible.</li> <li>Atributos por defecto si no se especifican.</li> </ul>"},{"location":"unit1/pydantic/#validacion-y-manejo-de-errores","title":"Validaci\u00f3n y manejo de errores","text":"<pre><code>from pydantic import ValidationError\n\ntry:\n    Usuario(nombre=\"Ana\", edad=\"no-es-numero\")\nexcept ValidationError as e:\n    print(e.json())\n</code></pre> <p>Esto devolver\u00e1 un error estructurado en formato JSON indicando qu\u00e9 campo fall\u00f3 y por qu\u00e9.</p>"},{"location":"unit1/pydantic/#campos-opcionales-y-valores-por-defecto","title":"Campos opcionales y valores por defecto","text":"<pre><code>from typing import Optional\n\nclass Libro(BaseModel):\n    titulo: str\n    autor: str\n    a\u00f1o: Optional[int] = None\n</code></pre>"},{"location":"unit1/pydantic/#validaciones-personalizadas","title":"Validaciones personalizadas","text":"<p>Puedes agregar validaciones propias usando decoradores:</p> <pre><code>from pydantic import validator\n\nclass Producto(BaseModel):\n    nombre: str\n    precio: float\n\n    @validator(\"precio\")\n    def precio_debe_ser_positivo(cls, v):\n        if v &lt;= 0:\n            raise ValueError(\"El precio debe ser mayor que cero\")\n        return v\n</code></pre>"},{"location":"unit1/pydantic/#anidacion-de-modelos","title":"Anidaci\u00f3n de modelos","text":"<pre><code>class Direccion(BaseModel):\n    ciudad: str\n    pais: str\n\nclass Empresa(BaseModel):\n    nombre: str\n    direccion: Direccion\n\ne = Empresa(nombre=\"Seth&amp;Nut\", direccion={\"ciudad\": \"Valpara\u00edso\", \"pais\": \"Chile\"})\nprint(e.direccion.ciudad)  # Valpara\u00edso\n</code></pre>"},{"location":"unit1/pydantic/#exportar-y-serializar-datos","title":"Exportar y serializar datos","text":"<pre><code>u = Usuario(nombre=\"Luis\", edad=28)\nprint(u.dict())     # Diccionario de Python\nprint(u.json())     # Cadena JSON\n</code></pre>"},{"location":"unit1/pydantic/#integracion-con-fastapi-y-otras-herramientas","title":"Integraci\u00f3n con FastAPI y otras herramientas","text":"<p>Pydantic se integra naturalmente con FastAPI, donde se usa para validar autom\u00e1ticamente las entradas de una API.</p> <pre><code>from fastapi import FastAPI\nfrom pydantic import BaseModel\n\nclass Item(BaseModel):\n    nombre: str\n    precio: float\n\napp = FastAPI()\n\n@app.post(\"/items/\")\ndef crear_item(item: Item):\n    return {\"resultado\": f\"{item.nombre} cuesta ${item.precio}\"}\n</code></pre>"},{"location":"unit1/pydantic/#buenas-practicas","title":"Buenas pr\u00e1cticas","text":"<p>\u2705 Usa <code>BaseModel</code> como clase base para todos tus modelos \u2705 Valida datos externos lo antes posible (por ejemplo, al recibir una request) \u2705 Usa <code>Optional[...]</code> solo cuando el valor puede ser <code>None</code> \u2705 Divide modelos grandes en submodelos reutilizables \u2705 Agrega validadores personalizados para reglas de negocio espec\u00edficas</p>"},{"location":"unit1/pydantic/#errores-comunes","title":"Errores comunes","text":"<p>\u274c Usar <code>Any</code> en todos los campos (pierde sentido el modelo) \u274c No capturar <code>ValidationError</code> si cargas datos de usuarios \u274c Esperar que los modelos funcionen como <code>dataclasses</code> puras (Pydantic hace m\u00e1s que eso) \u274c Modificar atributos directamente sin validaci\u00f3n extra (usar <code>@root_validator</code> si es necesario)</p>"},{"location":"unit1/pydantic/#referencias-utiles","title":"Referencias \u00fatiles","text":"<ul> <li>\ud83d\udcd8 Documentaci\u00f3n oficial de Pydantic</li> <li>\u2699\ufe0f Pydantic en FastAPI</li> <li>\ud83e\uddea Validadores personalizados</li> </ul>"},{"location":"unit1/pydantic/#conclusion","title":"Conclusi\u00f3n","text":"<p>Pydantic aporta una capa de seguridad y claridad en el manejo de datos en Python, especialmente cuando provienen de fuentes no confiables. Su combinaci\u00f3n con type hints y validaciones autom\u00e1ticas hace que los modelos sean robustos, auto-documentados y f\u00e1ciles de mantener. Es una herramienta fundamental para quienes buscan escribir software Python profesional, confiable y preparado para producci\u00f3n.</p>"},{"location":"unit1/pythonic/","title":"La magia del c\u00f3digo Pythonico","text":""},{"location":"unit1/pythonic/#introduccion","title":"Introducci\u00f3n","text":"<p>Una de las razones por las que Python es tan popular es su legibilidad y expresividad. Es un lenguaje dise\u00f1ado para que el c\u00f3digo sea f\u00e1cil de entender y mantener. Este estilo particular de escribir c\u00f3digo se conoce como \u201cPensamiento Pythonic\u201d (Pythonic Thinking).</p> <p>Ser \"pythonic\" no significa simplemente que el c\u00f3digo funcione, sino que est\u00e9 escrito de forma clara, idiom\u00e1tica y elegante. En este cap\u00edtulo exploraremos qu\u00e9 significa escribir c\u00f3digo pythonic, c\u00f3mo aplicar sus principios, y qu\u00e9 pr\u00e1cticas evitar para lograr un estilo m\u00e1s natural y profesional.</p>"},{"location":"unit1/pythonic/#que-significa-pythonic","title":"\u00bfQu\u00e9 significa \u201cPythonic\u201d?","text":"<p>Pythonic es un t\u00e9rmino informal que describe c\u00f3digo que aprovecha las caracter\u00edsticas y convenciones del lenguaje Python de manera idiom\u00e1tica. Es decir, c\u00f3digo que se ve y se comporta como \u201cse espera\u201d en la comunidad Python.</p> <p>\u2728 Escribir c\u00f3digo pythonic no es solo una cuesti\u00f3n de estilo, sino una forma de pensar: \u201cexpresar la intenci\u00f3n de forma clara y concisa\u201d.</p>"},{"location":"unit1/pythonic/#el-zen-de-python","title":"El Zen de Python","text":"<p>Puedes obtener una s\u00edntesis de la filosof\u00eda Python ejecutando:</p> <pre><code>import this\n</code></pre> <p>Esto imprimir\u00e1 los principios del Zen de Python, algunos destacados:</p> <ul> <li>Beautiful is better than ugly </li> <li>Simple is better than complex </li> <li>Readability counts </li> <li>There should be one\u2013 and preferably only one \u2013obvious way to do it </li> </ul> <p>Este conjunto de frases resume el esp\u00edritu detr\u00e1s del pensamiento Pythonic.</p>"},{"location":"unit1/pythonic/#ejemplos-de-codigo-pythonic-vs-no-pythonic","title":"Ejemplos de c\u00f3digo pythonic vs no pythonic","text":""},{"location":"unit1/pythonic/#1-condicionales-explicitos-innecesarios","title":"1. Condicionales expl\u00edcitos innecesarios","text":"<p>\u274c No pythonic:</p> <pre><code>if len(lista) != 0:\n    print(\"Lista no vac\u00eda\")\n</code></pre> <p>\u2705 Pythonic:</p> <pre><code>if lista:\n    print(\"Lista no vac\u00eda\")\n</code></pre>"},{"location":"unit1/pythonic/#2-iteracion-sobre-indices-en-lugar-de-elementos","title":"2. Iteraci\u00f3n sobre \u00edndices en lugar de elementos","text":"<p>\u274c No pythonic:</p> <pre><code>for i in range(len(nombres)):\n    print(nombres[i])\n</code></pre> <p>\u2705 Pythonic:</p> <pre><code>for nombre in nombres:\n    print(nombre)\n</code></pre>"},{"location":"unit1/pythonic/#3-usar-diccionarios-en-lugar-de-condicionales","title":"3. Usar diccionarios en lugar de condicionales","text":"<pre><code>mensajes = {\n    \"ok\": \"Todo bien\",\n    \"error\": \"Algo fall\u00f3\",\n}\n\nprint(mensajes.get(estado, \"Estado desconocido\"))\n</code></pre> <p>Evita estructuras condicionales largas y promueve una soluci\u00f3n m\u00e1s limpia.</p>"},{"location":"unit1/pythonic/#4-usar-comprensiones-en-lugar-de-bucles-largos","title":"4. Usar comprensiones en lugar de bucles largos","text":"<p>\u274c No pythonic:</p> <pre><code>cuadrados = []\nfor x in range(10):\n    cuadrados.append(x * x)\n</code></pre> <p>\u2705 Pythonic:</p> <pre><code>cuadrados = [x * x for x in range(10)]\n</code></pre>"},{"location":"unit1/pythonic/#5-evitar-codigo-innecesariamente-verboso","title":"5. Evitar c\u00f3digo innecesariamente verboso","text":"<p>\u274c No pythonic:</p> <pre><code>if activo == True:\n    ejecutar()\n</code></pre> <p>\u2705 Pythonic:</p> <pre><code>if activo:\n    ejecutar()\n</code></pre>"},{"location":"unit1/pythonic/#idioms-comunes-en-python","title":"Idioms comunes en Python","text":"<ul> <li><code>x or valor_predeterminado</code></li> <li><code>a if cond else b</code>  (expresi\u00f3n condicional)</li> <li><code>enumerate()</code> en vez de <code>range(len(...))</code></li> <li><code>zip()</code> para iterar sobre m\u00faltiples listas</li> <li><code>with open(...)</code> para manejo seguro de archivos</li> <li><code>try/except</code> para control de flujo en lugar de <code>if</code> defensivos</li> </ul>"},{"location":"unit1/pythonic/#buenas-practicas-para-escribir-codigo-pythonic","title":"Buenas pr\u00e1cticas para escribir c\u00f3digo Pythonic","text":"<p>\u2705 Lee mucho c\u00f3digo Python (open source, stdlib, docs oficiales) \u2705 Valora la legibilidad por sobre la brevedad excesiva \u2705 Refactoriza condicionales y bucles comunes con expresiones m\u00e1s claras \u2705 Usa funciones y expresiones idiom\u00e1ticas como <code>any()</code>, <code>all()</code>, <code>set()</code>, <code>dict.get()</code> \u2705 Sigue el Zen de Python como gu\u00eda filos\u00f3fica</p>"},{"location":"unit1/pythonic/#errores-comunes-al-intentar-ser-pythonic","title":"Errores comunes al intentar ser \u201cpythonic\u201d","text":"<p>\u274c Usar expresiones compactas que sacrifican claridad \u274c Abusar de <code>lambda</code> para l\u00f3gica compleja \u274c Intentar parecer \u201cclever\u201d en lugar de ser claro \u274c Mezclar estilos no idiom\u00e1ticos por falta de contexto</p> <p>\ud83e\udde0 Ser Pythonic no es seguir reglas estrictas, sino elegir la soluci\u00f3n m\u00e1s clara y natural dentro del lenguaje.</p>"},{"location":"unit1/pythonic/#referencias-utiles","title":"Referencias \u00fatiles","text":"<ul> <li>\ud83d\udcd8 PEP 20 \u2013 The Zen of Python</li> <li>\ud83d\udcda Fluent Python, Luciano Ramalho (Cap. 1 y 2)</li> <li>\ud83e\uddf0 Idiomatic Python Examples</li> </ul>"},{"location":"unit1/pythonic/#conclusion","title":"Conclusi\u00f3n","text":"<p>Pensar en t\u00e9rminos Pythonic es aprender a escribir c\u00f3digo que sea no solo correcto, sino tambi\u00e9n expresivo, legible y mantenible. Adoptar este enfoque te ayuda a comunicarte mejor con otros desarrolladores, a evitar errores comunes y a crear software m\u00e1s profesional y robusto.</p> <p>M\u00e1s que memorizar reglas, se trata de absorber una filosof\u00eda: escribir c\u00f3digo que se lea como prosa clara, sin sorpresas ni trampas.</p>"},{"location":"unit1/scripts/","title":"Scripts en Python","text":""},{"location":"unit1/scripts/#introduccion","title":"Introducci\u00f3n","text":"<p>Escribir funciones y clases es solo una parte del desarrollo en Python. Para que un programa funcione correctamente en la pr\u00e1ctica, tambi\u00e9n debemos entender c\u00f3mo se ejecutan los scripts, c\u00f3mo se organizan los archivos y c\u00f3mo importar m\u00f3dulos de forma efectiva.</p> <p>Este cap\u00edtulo presenta las convenciones y buenas pr\u00e1cticas relacionadas con la ejecuci\u00f3n de scripts, estructura m\u00ednima de proyectos Python y mecanismos de importaci\u00f3n, tanto para scripts peque\u00f1os como para proyectos m\u00e1s grandes.</p>"},{"location":"unit1/scripts/#ejecutar-scripts-en-python","title":"Ejecutar scripts en Python","text":"<p>El archivo m\u00e1s com\u00fan de ejecuci\u00f3n en Python es un script <code>.py</code>. Puedes ejecutarlo directamente desde la terminal:</p> <pre><code>python main.py\n</code></pre> <p>Tambi\u00e9n puedes hacerlo desde un entorno como VS Code, PyCharm o Jupyter.</p>"},{"location":"unit1/scripts/#if-__name__-__main__","title":"<code>if __name__ == \"__main__\"</code>","text":"<p>Esta l\u00ednea permite que un archivo Python se pueda ejecutar tanto como script principal como m\u00f3dulo importado.</p> <pre><code>def main():\n    print(\"Ejecutando script principal\")\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <p>\ud83d\udd0d Cuando el archivo se ejecuta directamente, <code>__name__</code> toma el valor <code>\"__main__\"</code>. Si se importa como m\u00f3dulo, <code>__name__</code> es el nombre del archivo o paquete.</p>"},{"location":"unit1/scripts/#como-importar-modulos-correctamente","title":"C\u00f3mo importar m\u00f3dulos correctamente","text":"<p>Python permite reutilizar c\u00f3digo importando funciones, clases o m\u00f3dulos desde otros archivos.</p>"},{"location":"unit1/scripts/#estructura-basica","title":"Estructura b\u00e1sica:","text":"<pre><code># archivo: utilidades.py\ndef saludar(nombre):\n    return f\"Hola, {nombre}\"\n</code></pre> <pre><code># archivo: main.py\nfrom utilidades import saludar\n\nprint(saludar(\"Francisco\"))\n</code></pre> <p>\ud83d\udcc2 Los archivos deben estar en el mismo directorio o en un m\u00f3dulo disponible en el <code>PYTHONPATH</code>.</p>"},{"location":"unit1/scripts/#importacion-absoluta-vs-relativa","title":"Importaci\u00f3n absoluta vs relativa","text":""},{"location":"unit1/scripts/#importacion-absoluta","title":"\ud83d\udd39 Importaci\u00f3n absoluta","text":"<p>M\u00e1s legible, recomendada en proyectos medianos y grandes.</p> <pre><code>from proyecto.modulo.util import funcion\n</code></pre>"},{"location":"unit1/scripts/#importacion-relativa","title":"\ud83d\udd38 Importaci\u00f3n relativa","text":"<p>\u00datil dentro de paquetes internos, aunque menos expl\u00edcita.</p> <pre><code>from .util import funcion\nfrom ..config import ajustes\n</code></pre> <p>\u2705 En la mayor\u00eda de los casos, prefiere la importaci\u00f3n absoluta, especialmente si el proyecto es p\u00fablico o colaborativo.</p>"},{"location":"unit1/scripts/#estructura-minima-de-un-proyecto-python","title":"Estructura m\u00ednima de un proyecto Python","text":"<p>Aqu\u00ed una estructura com\u00fan y profesional:</p> <pre><code>mi_proyecto/\n\u2502\n\u251c\u2500\u2500 src/                     # C\u00f3digo fuente principal\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 main.py\n\u2502   \u2514\u2500\u2500 modulo/\n\u2502       \u251c\u2500\u2500 __init__.py\n\u2502       \u2514\u2500\u2500 operaciones.py\n\u2502\n\u251c\u2500\u2500 tests/                  # Pruebas unitarias\n\u2502   \u2514\u2500\u2500 test_operaciones.py\n\u2502\n\u251c\u2500\u2500 requirements.txt        # Dependencias\n\u251c\u2500\u2500 README.md               # Documentaci\u00f3n del proyecto\n\u2514\u2500\u2500 pyproject.toml / setup.py # Configuraci\u00f3n del paquete\n</code></pre> <p>Para ejecutar correctamente desde <code>src/</code>, puedes usar:</p> <pre><code>PYTHONPATH=src python src/main.py\n</code></pre> <p>O agregar un <code>__init__.py</code> en cada subcarpeta para que Python lo reconozca como paquete.</p>"},{"location":"unit1/scripts/#buenas-practicas","title":"Buenas pr\u00e1cticas","text":"<p>\u2705 Siempre usa <code>if __name__ == \"__main__\"</code> en scripts ejecutables \u2705 Organiza tu c\u00f3digo en m\u00f3dulos y paquetes, no todo en un solo archivo \u2705 Usa importaciones absolutas por claridad \u2705 Mant\u00e9n una estructura consistente en todos tus proyectos \u2705 Usa <code>src/</code> si planeas distribuir tu c\u00f3digo como paquete</p>"},{"location":"unit1/scripts/#errores-comunes","title":"Errores comunes","text":"<p>\u274c No usar <code>__name__ == \"__main__\"</code> y ejecutar scripts importados involuntariamente \u274c Nombres de archivos que colisionan con m\u00f3dulos est\u00e1ndar (<code>random.py</code>, <code>json.py</code>) \u274c Importaciones circulares entre m\u00f3dulos \u274c Copiar/pegar c\u00f3digo entre scripts en lugar de modularizarlo \u274c Ejecutar m\u00f3dulos sin configurar el entorno (ej: sin definir <code>PYTHONPATH</code>)</p>"},{"location":"unit1/scripts/#recursos-recomendados","title":"Recursos recomendados","text":"<ul> <li>\ud83d\udcd8 The Module System \u2013 Python Docs</li> <li>\ud83d\udcc1 Structuring Your Project</li> <li>\ud83e\uddea Effective Python \u2013 Brett Slatkin</li> </ul>"},{"location":"unit1/scripts/#conclusion","title":"Conclusi\u00f3n","text":"<p>Comprender c\u00f3mo se organizan, ejecutan e interconectan los archivos Python es un paso clave para escalar tu c\u00f3digo de scripts simples a aplicaciones modulares y mantenibles. Un buen dise\u00f1o empieza con una buena estructura de carpetas, archivos bien nombrados y un uso claro de <code>import</code> y <code>main</code>.</p>"},{"location":"unit1/typing/","title":"Tipado moderno - Typing","text":""},{"location":"unit1/typing/#introduccion","title":"Introducci\u00f3n","text":"<p>Aunque Python es un lenguaje de tipado din\u00e1mico, desde la versi\u00f3n 3.5 ha incorporado soporte para tipado est\u00e1tico mediante type hints. Esta funcionalidad permite a los desarrolladores declarar los tipos de variables, argumentos y retornos de funciones, lo cual mejora la legibilidad del c\u00f3digo y permite la detecci\u00f3n temprana de errores mediante herramientas externas.</p> <p>En este cap\u00edtulo aprender\u00e1s a usar anotaciones de tipo de forma pr\u00e1ctica y progresiva, entendiendo su utilidad, sintaxis, beneficios y c\u00f3mo integrarlas con herramientas como <code>mypy</code> y <code>Pyright</code>.</p>"},{"location":"unit1/typing/#que-es-el-tipado-estatico","title":"\u00bfQu\u00e9 es el tipado est\u00e1tico?","text":"<p>El tipado est\u00e1tico consiste en declarar los tipos de variables y funciones para que puedan ser verificados antes de ejecutar el c\u00f3digo. En Python, esto es completamente opcional, pero se ha convertido en una pr\u00e1ctica com\u00fan en proyectos profesionales.</p> <p>Python sigue siendo din\u00e1mico en tiempo de ejecuci\u00f3n, pero con type hints puedes aplicar an\u00e1lisis est\u00e1tico con herramientas externas.</p>"},{"location":"unit1/typing/#sintaxis-basica-de-anotaciones-de-tipo","title":"Sintaxis b\u00e1sica de anotaciones de tipo","text":""},{"location":"unit1/typing/#funciones-con-anotaciones","title":"Funciones con anotaciones","text":"<pre><code>def saludar(nombre: str) -&gt; str:\n    return f\"Hola, {nombre}\"\n</code></pre>"},{"location":"unit1/typing/#variables-con-anotaciones","title":"Variables con anotaciones","text":"<pre><code>edad: int = 30\nes_activo: bool = True\n</code></pre> <p>\u2705 Estas anotaciones no afectan la ejecuci\u00f3n del programa, pero permiten a linters y editores ofrecer mejores sugerencias y validaciones.</p>"},{"location":"unit1/typing/#tipos-comunes","title":"Tipos comunes","text":"Tipo Python Descripci\u00f3n <code>int</code> N\u00fameros enteros <code>float</code> N\u00fameros decimales <code>str</code> Cadenas de texto <code>bool</code> Booleanos (<code>True</code>, <code>False</code>) <code>list[str]</code> Lista de cadenas <code>dict[str, int]</code> Diccionario con claves <code>str</code> y valores <code>int</code>"},{"location":"unit1/typing/#ejemplo","title":"Ejemplo","text":"<pre><code>def obtener_edades() -&gt; dict[str, int]:\n    return {\"Ana\": 25, \"Luis\": 32}\n</code></pre>"},{"location":"unit1/typing/#anotaciones-avanzadas","title":"Anotaciones avanzadas","text":""},{"location":"unit1/typing/#1-union-y-optional","title":"1. <code>Union</code> y <code>Optional</code>","text":"<pre><code>from typing import Union, Optional\n\ndef procesar(valor: Union[int, str]) -&gt; str:\n    return str(valor)\n\ndef buscar(id: int) -&gt; Optional[str]:\n    return \"dato\" if id == 1 else None\n</code></pre> <ul> <li><code>Union[int, str]</code>: acepta uno u otro.</li> <li><code>Optional[str]</code>: igual a <code>Union[str, None]</code>.</li> </ul>"},{"location":"unit1/typing/#2-any-y-literal","title":"2. <code>Any</code> y <code>Literal</code>","text":"<pre><code>from typing import Any, Literal\n\ndef debug(valor: Any) -&gt; None:\n    print(valor)\n\ndef set_estado(estado: Literal[\"activo\", \"inactivo\"]) -&gt; None:\n    pass\n</code></pre> <ul> <li><code>Any</code>: desactiva el chequeo de tipos.</li> <li><code>Literal</code>: restringe a valores espec\u00edficos.</li> </ul>"},{"location":"unit1/typing/#3-typeddict-newtype-typealias","title":"3. <code>TypedDict</code>, <code>NewType</code>, <code>TypeAlias</code>","text":"<pre><code>from typing import TypedDict, NewType\n\nclass Usuario(TypedDict):\n    nombre: str\n    edad: int\n\nUserID = NewType(\"UserID\", int)\n</code></pre> <ul> <li><code>TypedDict</code>: estructuras con forma de diccionarios.</li> <li><code>NewType</code>: define nuevos identificadores de tipo.</li> </ul>"},{"location":"unit1/typing/#tipado-en-colecciones","title":"Tipado en colecciones","text":"<pre><code>from typing import List, Tuple, Dict\n\nnombres: List[str] = [\"Ana\", \"Luis\"]\ncoordenadas: Tuple[float, float] = (33.5, -70.6)\npersonas: Dict[str, int] = {\"Ana\": 25, \"Luis\": 32}\n</code></pre> <p>A partir de Python 3.9 se puede usar la sintaxis corta: <code>list[str]</code>, <code>tuple[str, int]</code>.</p>"},{"location":"unit1/typing/#uso-con-mypy-y-otros-analizadores","title":"Uso con <code>mypy</code> y otros analizadores","text":""},{"location":"unit1/typing/#instalacion-de-mypy","title":"Instalaci\u00f3n de <code>mypy</code>","text":"<pre><code>pip install mypy\n</code></pre>"},{"location":"unit1/typing/#ejemplo-de-analisis","title":"Ejemplo de an\u00e1lisis","text":"<pre><code>mypy archivo.py\n</code></pre> <p>Esto revisar\u00e1 si las anotaciones son coherentes con el uso del c\u00f3digo. Tambi\u00e9n puedes integrarlo en tu CI/CD.</p>"},{"location":"unit1/typing/#alternativas","title":"Alternativas:","text":"<ul> <li><code>pyright</code>: analizador r\u00e1pido desarrollado por Microsoft (VS Code).</li> <li><code>pyre</code>: analizador de tipos est\u00e1tico creado por Meta.</li> </ul>"},{"location":"unit1/typing/#buenas-practicas","title":"Buenas pr\u00e1cticas","text":"<p>\u2705 A\u00f1ade anotaciones especialmente en funciones p\u00fablicas o de librer\u00edas \u2705 Usa <code>Optional</code> y <code>Union</code> para modelar correctamente entradas flexibles \u2705 Prefiere <code>list[int]</code> sobre <code>List[int]</code> si usas Python \u2265 3.9 \u2705 Acompa\u00f1a el tipado con herramientas como <code>mypy</code> o <code>ruff check</code> </p>"},{"location":"unit1/typing/#errores-comunes","title":"Errores comunes","text":"<p>\u274c Pensar que las anotaciones obligan el tipo en tiempo de ejecuci\u00f3n \u274c Usar <code>Any</code> en exceso (pierde valor el an\u00e1lisis) \u274c Ignorar advertencias de <code>mypy</code> sin analizarlas \u274c Mezclar anotaciones incompletas con funciones complejas</p>"},{"location":"unit1/typing/#referencias-utiles","title":"Referencias \u00fatiles","text":"<ul> <li>\ud83d\udcd8 PEP 484 \u2013 Type Hints</li> <li>\ud83e\uddf0 Typing \u2013 M\u00f3dulo oficial</li> <li>\ud83d\udcda mypy \u2013 Documentaci\u00f3n oficial</li> <li>\ud83d\ude80 pyright \u2013 Type Checker para Python</li> </ul>"},{"location":"unit1/typing/#conclusion","title":"Conclusi\u00f3n","text":"<p>El tipado est\u00e1tico en Python no es obligatorio, pero su adopci\u00f3n ha demostrado ser un recurso valioso para detectar errores antes de ejecutar el c\u00f3digo, mejorar la documentaci\u00f3n impl\u00edcita y facilitar la colaboraci\u00f3n en equipos. Usar <code>typing</code> junto con herramientas de an\u00e1lisis convierte tu c\u00f3digo en una fuente m\u00e1s confiable y robusta, sin sacrificar la flexibilidad que caracteriza a Python.</p>"},{"location":"unit2/","title":"\ud83e\udde0 Unidad 2: Dise\u00f1o de Software","text":"<p>Exploramos principios y herramientas que permiten construir software limpio, extensible y f\u00e1cil de mantener.</p>"},{"location":"unit2/#contenidos","title":"Contenidos","text":"<ul> <li>Principios SOLID</li> <li>Patrones de dise\u00f1o cl\u00e1sicos</li> <li>Refactorizaci\u00f3n de c\u00f3digo heredado</li> <li>Estructura de proyectos en Python</li> </ul>"},{"location":"unit2/#objetivos","title":"Objetivos","text":"<ul> <li>Dise\u00f1ar software siguiendo principios robustos.</li> <li>Aplicar patrones de dise\u00f1o seg\u00fan las necesidades del sistema.</li> <li>Reorganizar c\u00f3digo para mejorar su claridad y mantenibilidad.</li> </ul>"},{"location":"unit2/#recursos","title":"Recursos","text":"<ul> <li>solid.md</li> <li>design_pattern.md</li> <li>refactoring.md</li> <li>structure.md</li> </ul>"},{"location":"unit2/design_pattern/","title":"Patrones de Dise\u00f1o","text":""},{"location":"unit2/design_pattern/#introduccion","title":"Introducci\u00f3n","text":"<p>Los patrones de dise\u00f1o son soluciones reutilizables a problemas comunes en el desarrollo de software. No son fragmentos de c\u00f3digo listos para copiar y pegar, sino estructuras probadas que ayudan a dise\u00f1ar sistemas m\u00e1s claros, extensibles y robustos.</p> <p>En Python, gracias a su flexibilidad y naturaleza din\u00e1mica, muchos patrones pueden implementarse de manera m\u00e1s sencilla que en lenguajes m\u00e1s est\u00e1ticos. Este cap\u00edtulo explora algunos de los patrones m\u00e1s \u00fatiles y c\u00f3mo aplicarlos en el contexto de desarrollo moderno con Python.</p>"},{"location":"unit2/design_pattern/#por-que-usar-patrones-de-diseno","title":"\u00bfPor qu\u00e9 usar patrones de dise\u00f1o?","text":"<ul> <li>\ud83d\udca1 Estandarizan soluciones en equipos y comunidades.</li> <li>\ud83e\udde9 Promueven la reutilizaci\u00f3n del conocimiento.</li> <li>\ud83d\udcd0 Mejoran la arquitectura de sistemas complejos.</li> <li>\ud83d\udeab Ayudan a evitar malas pr\u00e1cticas como duplicaci\u00f3n o acoplamiento innecesario.</li> </ul>"},{"location":"unit2/design_pattern/#clasificacion-de-los-patrones","title":"Clasificaci\u00f3n de los patrones","text":"<p>Los patrones se suelen dividir en tres categor\u00edas principales:</p> Tipo Prop\u00f3sito Ejemplos comunes Creacionales Controlar la creaci\u00f3n de objetos Singleton, Factory, Builder Estructurales Organizar relaciones entre clases Adapter, Decorator, Composite Comportamiento Gestionar algoritmos y responsabilidades Strategy, Observer, Command"},{"location":"unit2/design_pattern/#1-singleton-un-solo-objeto-global","title":"1. Singleton \u2013 Un solo objeto global","text":""},{"location":"unit2/design_pattern/#uso-tipico","title":"Uso t\u00edpico:","text":"<p>Cuando necesitas garantizar que solo haya una \u00fanica instancia de una clase (como una conexi\u00f3n global o una configuraci\u00f3n).</p>"},{"location":"unit2/design_pattern/#ejemplo-en-python","title":"Ejemplo en Python:","text":"<pre><code>class Config:\n    _instancia = None\n\n    def __new__(cls):\n        if cls._instancia is None:\n            cls._instancia = super().__new__(cls)\n        return cls._instancia\n\nconfig1 = Config()\nconfig2 = Config()\nprint(config1 is config2)  # True\n</code></pre> <p>\u261d\ufe0f Usa este patr\u00f3n con precauci\u00f3n. A menudo se prefiere la inyecci\u00f3n de dependencias sobre el acceso global.</p>"},{"location":"unit2/design_pattern/#2-factory-crear-objetos-segun-condiciones","title":"2. Factory \u2013 Crear objetos seg\u00fan condiciones","text":""},{"location":"unit2/design_pattern/#uso-tipico_1","title":"Uso t\u00edpico:","text":"<p>Cuando quieres delegar la creaci\u00f3n de objetos sin acoplarte a clases concretas.</p> <pre><code>class Perro:\n    def hablar(self):\n        return \"Guau\"\n\nclass Gato:\n    def hablar(self):\n        return \"Miau\"\n\ndef fabrica_animal(tipo: str):\n    clases = {\"perro\": Perro, \"gato\": Gato}\n    return clases[tipo]()\n\nanimal = fabrica_animal(\"gato\")\nprint(animal.hablar())  # Miau\n</code></pre> <p>\ud83d\udd0d El patr\u00f3n Factory es muy \u00fatil cuando los tipos a crear pueden cambiar din\u00e1micamente.</p>"},{"location":"unit2/design_pattern/#3-strategy-intercambiar-algoritmos","title":"3. Strategy \u2013 Intercambiar algoritmos","text":""},{"location":"unit2/design_pattern/#uso-tipico_2","title":"Uso t\u00edpico:","text":"<p>Cuando tienes m\u00faltiples formas de realizar una tarea y quieres que el algoritmo sea intercambiable sin modificar el c\u00f3digo que lo usa.</p> <pre><code>class PagoEstrategia:\n    def pagar(self, monto): pass\n\nclass PagoPaypal(PagoEstrategia):\n    def pagar(self, monto):\n        print(f\"Pagando ${monto} con PayPal\")\n\nclass PagoTarjeta(PagoEstrategia):\n    def pagar(self, monto):\n        print(f\"Pagando ${monto} con Tarjeta\")\n\nclass Tienda:\n    def __init__(self, estrategia: PagoEstrategia):\n        self.estrategia = estrategia\n\n    def procesar_pago(self, monto):\n        self.estrategia.pagar(monto)\n\nt = Tienda(PagoTarjeta())\nt.procesar_pago(100)\n</code></pre> <p>\ud83d\udca1 Ideal para sistemas extensibles donde las reglas cambian seg\u00fan el contexto.</p>"},{"location":"unit2/design_pattern/#4-decorator-anadir-funcionalidad-sin-modificar-clases","title":"4. Decorator \u2013 A\u00f1adir funcionalidad sin modificar clases","text":""},{"location":"unit2/design_pattern/#uso-tipico_3","title":"Uso t\u00edpico:","text":"<p>Agregar comportamiento a objetos sin modificar su estructura original.</p> <pre><code>def auditar(func):\n    def envoltura(*args, **kwargs):\n        print(\"Ejecutando:\", func.__name__)\n        return func(*args, **kwargs)\n    return envoltura\n\n@auditar\ndef saludar():\n    print(\"\u00a1Hola!\")\n\nsaludar()\n</code></pre> <p>\ud83e\udde9 Python lo hace especialmente f\u00e1cil gracias a su sintaxis con <code>@decorators</code>.</p>"},{"location":"unit2/design_pattern/#5-observer-reaccionar-a-cambios-en-tiempo-real","title":"5. Observer \u2013 Reaccionar a cambios en tiempo real","text":""},{"location":"unit2/design_pattern/#uso-tipico_4","title":"Uso t\u00edpico:","text":"<p>Cuando m\u00faltiples objetos deben ser notificados autom\u00e1ticamente ante un cambio en otro.</p> <pre><code>class Sujeto:\n    def __init__(self):\n        self._observadores = []\n\n    def suscribir(self, obs):\n        self._observadores.append(obs)\n\n    def notificar(self, mensaje):\n        for obs in self._observadores:\n            obs.actualizar(mensaje)\n\nclass Observador:\n    def actualizar(self, mensaje):\n        print(\"Notificaci\u00f3n:\", mensaje)\n\nsujeto = Sujeto()\nobs1 = Observador()\nsujeto.suscribir(obs1)\nsujeto.notificar(\"Nuevo evento\")\n</code></pre> <p>\ud83d\udd14 Muy usado en interfaces gr\u00e1ficas, sistemas de eventos o notificaciones.</p>"},{"location":"unit2/design_pattern/#buenas-practicas-al-usar-patrones","title":"Buenas pr\u00e1cticas al usar patrones","text":"<p>\u2705 Usa patrones cuando el problema lo justifique, no por moda \u2705 Refactoriza c\u00f3digo repetitivo o acoplado en torno a un patr\u00f3n claro \u2705 Combina patrones si es necesario (ej. Strategy + Factory) \u2705 Documenta bien el prop\u00f3sito del patr\u00f3n en tu c\u00f3digo  </p>"},{"location":"unit2/design_pattern/#errores-comunes","title":"Errores comunes","text":"<p>\u274c Sobreingenier\u00eda: aplicar patrones innecesarios para problemas simples \u274c Usar clases abstractas donde Python permite funciones o duck typing \u274c Forzar herencia donde ser\u00eda mejor composici\u00f3n \u274c Implementar patrones \u201ccomo en Java\u201d sin aprovechar la idiomaticidad de Python</p>"},{"location":"unit2/design_pattern/#recursos-recomendados","title":"Recursos recomendados","text":"<ul> <li>\ud83d\udcd8 Refactoring.Guru \u2013 Design Patterns</li> <li>\ud83d\udcda Head First Design Patterns (adaptado a Python)</li> <li>\ud83e\uddf0 Python Patterns (GitHub)</li> <li>\ud83d\udc0d Fluent Python, Luciano Ramalho \u2013 Cap\u00edtulos sobre dise\u00f1o avanzado</li> </ul>"},{"location":"unit2/design_pattern/#conclusion","title":"Conclusi\u00f3n","text":"<p>Los patrones de dise\u00f1o no son reglas estrictas, sino soluciones flexibles para problemas frecuentes en la arquitectura de software. Aplicarlos correctamente en Python requiere entender tanto el patr\u00f3n como las fortalezas del lenguaje. Con pr\u00e1ctica y criterio, los patrones pueden ayudarte a escribir software m\u00e1s limpio, mantenible y preparado para crecer.</p>"},{"location":"unit2/refactoring/","title":"Refactorizaci\u00f3n de C\u00f3digo","text":""},{"location":"unit2/refactoring/#introduccion","title":"Introducci\u00f3n","text":"<p>A medida que el software crece, el c\u00f3digo tiende a volverse m\u00e1s complejo, repetitivo o dif\u00edcil de mantener. Refactorizar es el proceso de reestructurar ese c\u00f3digo \u2014mejorando su legibilidad y dise\u00f1o interno\u2014 sin modificar su comportamiento externo.</p> <p>Refactorizar no es algo que se hace solo al final de un proyecto: es una pr\u00e1ctica continua que distingue al desarrollador profesional. Este cap\u00edtulo presenta los principios, t\u00e9cnicas y patrones comunes de refactorizaci\u00f3n en Python.</p>"},{"location":"unit2/refactoring/#que-es-la-refactorizacion","title":"\u00bfQu\u00e9 es la refactorizaci\u00f3n?","text":"<p>La refactorizaci\u00f3n consiste en cambiar la estructura del c\u00f3digo para que sea m\u00e1s limpio, comprensible y mantenible, sin alterar lo que hace. Es como reorganizar una habitaci\u00f3n: todo sigue estando all\u00ed, pero es m\u00e1s f\u00e1cil de usar.</p> <p>\ud83d\udca1 Refactorizar no es optimizar. Optimizar busca rendimiento. Refactorizar busca claridad.</p>"},{"location":"unit2/refactoring/#cuando-refactorizar","title":"\u00bfCu\u00e1ndo refactorizar?","text":"<ul> <li>Antes de agregar nuevas funcionalidades</li> <li>Cuando detectas duplicaci\u00f3n de c\u00f3digo</li> <li>Al ver funciones/clases demasiado largas o acopladas</li> <li>Cuando otros no pueden entender tu c\u00f3digo sin ayuda</li> <li>Como parte del ciclo: escribe \u2013 prueba \u2013 refactoriza</li> </ul>"},{"location":"unit2/refactoring/#principios-clave","title":"Principios clave","text":"<ul> <li>\ud83d\udd01 Peque\u00f1os pasos: haz cambios incrementales, f\u00e1ciles de testear.</li> <li>\ud83e\uddea Red de seguridad: aseg\u00farate de tener pruebas automatizadas.</li> <li>\ud83e\udde0 Mant\u00e9n la intenci\u00f3n clara: el c\u00f3digo debe ser m\u00e1s legible despu\u00e9s de refactorizar.</li> <li>\u270b No refactorices mientras implementas funcionalidades nuevas.</li> </ul>"},{"location":"unit2/refactoring/#ejemplos-comunes-de-refactorizacion","title":"Ejemplos comunes de refactorizaci\u00f3n","text":""},{"location":"unit2/refactoring/#renombrar-variables-y-funciones","title":"\u2705 Renombrar variables y funciones","text":"<p>\u274c Antes:</p> <pre><code>def calc(x, y):\n    return x * y\n</code></pre> <p>\u2705 Despu\u00e9s:</p> <pre><code>def calcular_area(base, altura):\n    return base * altura\n</code></pre>"},{"location":"unit2/refactoring/#extraer-funciones","title":"\u2705 Extraer funciones","text":"<p>Cuando una funci\u00f3n hace muchas cosas, sep\u00e1rala en partes m\u00e1s claras:</p> <pre><code>def procesar_usuario(usuario):\n    if not usuario.get(\"activo\"):\n        return \"Inactivo\"\n    enviar_bienvenida(usuario[\"email\"])\n    return \"Activo\"\n</code></pre> <p>Separado:</p> <pre><code>def es_activo(usuario):\n    return usuario.get(\"activo\", False)\n\ndef enviar_bienvenida(email):\n    print(f\"Correo enviado a {email}\")\n\ndef procesar_usuario(usuario):\n    if not es_activo(usuario):\n        return \"Inactivo\"\n    enviar_bienvenida(usuario[\"email\"])\n    return \"Activo\"\n</code></pre>"},{"location":"unit2/refactoring/#eliminar-duplicacion","title":"\u2705 Eliminar duplicaci\u00f3n","text":"<p>Antes:</p> <pre><code>def area_rectangulo(base, altura):\n    return base * altura\n\ndef area_paralelogramo(base, altura):\n    return base * altura\n</code></pre> <p>Despu\u00e9s:</p> <pre><code>def calcular_area(base, altura):\n    return base * altura\n</code></pre>"},{"location":"unit2/refactoring/#usar-estructuras-idiomaticas-de-python","title":"\u2705 Usar estructuras idiom\u00e1ticas de Python","text":"<p>Antes:</p> <pre><code>valores = []\nfor x in datos:\n    if x &gt; 0:\n        valores.append(x)\n</code></pre> <p>Despu\u00e9s:</p> <pre><code>valores = [x for x in datos if x &gt; 0]\n</code></pre>"},{"location":"unit2/refactoring/#refactorizaciones-estructurales","title":"Refactorizaciones estructurales","text":""},{"location":"unit2/refactoring/#separar-responsabilidades-single-responsibility","title":"\ud83d\udd39 Separar responsabilidades (Single Responsibility)","text":"<pre><code>class Factura:\n    def calcular_total(self): ...\n    def exportar_pdf(self): ...  # \u274c mezcla l\u00f3gica de presentaci\u00f3n\n</code></pre> <p>\u2705 Refactorizado:</p> <pre><code>class Factura:\n    def calcular_total(self): ...\n\nclass ExportadorFacturaPDF:\n    def exportar(self, factura: Factura): ...\n</code></pre>"},{"location":"unit2/refactoring/#reemplazar-condicionales-con-polimorfismo","title":"\ud83d\udd39 Reemplazar condicionales con polimorfismo","text":"<pre><code>def calcular_total(tipo, monto):\n    if tipo == \"normal\":\n        return monto\n    elif tipo == \"descuento\":\n        return monto * 0.9\n</code></pre> <p>\u2705 Refactorizado:</p> <pre><code>class EstrategiaPrecio:\n    def calcular(self, monto): ...\n\nclass Normal(EstrategiaPrecio):\n    def calcular(self, monto):\n        return monto\n\nclass ConDescuento(EstrategiaPrecio):\n    def calcular(self, monto):\n        return monto * 0.9\n</code></pre>"},{"location":"unit2/refactoring/#herramientas-utiles","title":"Herramientas \u00fatiles","text":"Herramienta Uso principal <code>black</code> Reformatador autom\u00e1tico <code>ruff</code> Linter y verificador de estilo <code>pytest</code> Pruebas antes/despu\u00e9s de refactorizar IDEs (VS Code, PyCharm) Soporte para renombrar, extraer funciones, mover clases"},{"location":"unit2/refactoring/#buenas-practicas","title":"Buenas pr\u00e1cticas","text":"<p>\u2705 Refactoriza con intenci\u00f3n: mejora la claridad o extensibilidad \u2705 Haz refactorizaciones peque\u00f1as y reversibles \u2705 Usa herramientas autom\u00e1ticas para detectar oportunidades (<code>ruff</code>, <code>flake8</code>) \u2705 Acompa\u00f1a tus cambios con tests autom\u00e1ticos</p>"},{"location":"unit2/refactoring/#errores-comunes","title":"Errores comunes","text":"<p>\u274c Refactorizar sin pruebas que respalden el comportamiento \u274c Hacer refactorizaciones grandes sin revisar impacto \u274c Cambiar nombres sin prop\u00f3sito (confunde al equipo) \u274c Refactorizar al mismo tiempo que implementas una nueva feature</p>"},{"location":"unit2/refactoring/#recursos-recomendados","title":"Recursos recomendados","text":"<ul> <li>\ud83d\udcd8 Refactoring (Martin Fowler)</li> <li>\ud83e\uddf0 Python Refactoring Toolkit (GitHub)</li> <li>\ud83d\udc0d [Clean Code \u2013 Robert C. Martin]</li> <li>\ud83e\uddea pytest + black + ruff</li> </ul>"},{"location":"unit2/refactoring/#conclusion","title":"Conclusi\u00f3n","text":"<p>Refactorizar no es una acci\u00f3n puntual, sino una pr\u00e1ctica continua del desarrollo profesional. Mejora la salud del c\u00f3digo, reduce el riesgo de errores y facilita que tu software pueda evolucionar con el tiempo. Al dominar la refactorizaci\u00f3n, conviertes c\u00f3digo fr\u00e1gil en estructuras s\u00f3lidas y adaptables.</p>"},{"location":"unit2/solid/","title":"Principio SOLID","text":""},{"location":"unit2/solid/#introduccion","title":"Introducci\u00f3n","text":"<p>Los principios SOLID son cinco directrices fundamentales del dise\u00f1o orientado a objetos, formuladas para escribir software que sea f\u00e1cil de entender, mantener y escalar. Aunque surgieron en lenguajes como C++ y Java, se aplican perfectamente a Python y son una base clave del dise\u00f1o profesional de software.</p> <p>Este cap\u00edtulo presenta los principios SOLID con ejemplos concretos en Python, buenas pr\u00e1cticas y advertencias sobre errores comunes.</p>"},{"location":"unit2/solid/#que-significa-solid","title":"\u00bfQu\u00e9 significa SOLID?","text":"<p>Cada letra representa un principio:</p> Letra Nombre Descripci\u00f3n breve S Single Responsibility Principle (SRP) Una clase debe tener una sola raz\u00f3n para cambiar. O Open/Closed Principle (OCP) El c\u00f3digo debe estar abierto a extensi\u00f3n, cerrado a modificaci\u00f3n. L Liskov Substitution Principle (LSP) Las subclases deben poder reemplazar a sus superclases. I Interface Segregation Principle (ISP) No forzar a los objetos a implementar m\u00e9todos que no usan. D Dependency Inversion Principle (DIP) Depender de abstracciones, no de implementaciones concretas."},{"location":"unit2/solid/#1-srp-principio-de-responsabilidad-unica","title":"1. SRP \u2013 Principio de Responsabilidad \u00danica","text":"<p>\"Una clase debe tener una sola raz\u00f3n para cambiar.\"</p>"},{"location":"unit2/solid/#no-srp","title":"\u274c No SRP","text":"<pre><code>class Reporte:\n    def generar(self):\n        # l\u00f3gica de negocio\n        pass\n\n    def exportar_pdf(self):\n        # l\u00f3gica de presentaci\u00f3n\n        pass\n</code></pre> <p>Esta clase mezcla l\u00f3gica de negocio con l\u00f3gica de presentaci\u00f3n.</p>"},{"location":"unit2/solid/#con-srp","title":"\u2705 Con SRP","text":"<pre><code>class Reporte:\n    def generar(self):\n        return {\"contenido\": \"datos\"}\n\nclass ExportadorPDF:\n    def exportar(self, data):\n        print(\"Exportando PDF:\", data)\n</code></pre>"},{"location":"unit2/solid/#2-ocp-principio-abiertocerrado","title":"2. OCP \u2013 Principio Abierto/Cerrado","text":"<p>\"El c\u00f3digo debe estar abierto a extensi\u00f3n, pero cerrado a modificaci\u00f3n.\"</p>"},{"location":"unit2/solid/#sin-ocp","title":"\u274c Sin OCP","text":"<pre><code>def calcular_precio(producto, tipo):\n    if tipo == \"normal\":\n        return producto.precio\n    elif tipo == \"descuento\":\n        return producto.precio * 0.9\n</code></pre> <p>Cada nuevo tipo rompe el c\u00f3digo existente.</p>"},{"location":"unit2/solid/#con-ocp","title":"\u2705 Con OCP","text":"<pre><code>class EstrategiaPrecio:\n    def calcular(self, producto):\n        raise NotImplementedError()\n\nclass PrecioNormal(EstrategiaPrecio):\n    def calcular(self, producto):\n        return producto.precio\n\nclass PrecioConDescuento(EstrategiaPrecio):\n    def calcular(self, producto):\n        return producto.precio * 0.9\n</code></pre>"},{"location":"unit2/solid/#3-lsp-principio-de-sustitucion-de-liskov","title":"3. LSP \u2013 Principio de Sustituci\u00f3n de Liskov","text":"<p>\"Las subclases deben ser sustituibles por sus superclases sin romper el programa.\"</p>"},{"location":"unit2/solid/#violacion-lsp","title":"\u274c Violaci\u00f3n LSP","text":"<pre><code>class Pato:\n    def volar(self):\n        return \"vuela\"\n\nclass PatoDeGoma(Pato):\n    def volar(self):\n        raise Exception(\"\u00a1No puede volar!\")\n</code></pre>"},{"location":"unit2/solid/#cumplimiento-lsp","title":"\u2705 Cumplimiento LSP","text":"<pre><code>class Ave:\n    def hacer_sonido(self):\n        pass\n\nclass Pato(Ave):\n    def hacer_sonido(self):\n        return \"cuac\"\n\nclass PatoDeGoma(Ave):\n    def hacer_sonido(self):\n        return \"chirriido\"\n</code></pre>"},{"location":"unit2/solid/#4-isp-principio-de-segregacion-de-interfaces","title":"4. ISP \u2013 Principio de Segregaci\u00f3n de Interfaces","text":"<p>\"Una clase no debe estar obligada a implementar m\u00e9todos que no necesita.\"</p> <p>Python no tiene interfaces expl\u00edcitas, pero este principio se aplica en dise\u00f1o de clases y herencias.</p>"},{"location":"unit2/solid/#mal-diseno","title":"\u274c Mal dise\u00f1o","text":"<pre><code>class Animal:\n    def volar(self): ...\n    def nadar(self): ...\n</code></pre> <p>No todos los animales hacen ambas cosas.</p>"},{"location":"unit2/solid/#buen-diseno","title":"\u2705 Buen dise\u00f1o","text":"<pre><code>class PuedeNadar:\n    def nadar(self): ...\n\nclass PuedeVolar:\n    def volar(self): ...\n</code></pre> <p>Cada clase implementa solo lo que necesita.</p>"},{"location":"unit2/solid/#5-dip-principio-de-inversion-de-dependencias","title":"5. DIP \u2013 Principio de Inversi\u00f3n de Dependencias","text":"<p>\"Depende de abstracciones, no de implementaciones concretas.\"</p>"},{"location":"unit2/solid/#acoplamiento-fuerte","title":"\u274c Acoplamiento fuerte","text":"<pre><code>class ServicioCorreo:\n    def enviar(self, mensaje):\n        print(\"Enviando correo:\", mensaje)\n\nclass Notificador:\n    def __init__(self):\n        self.correo = ServicioCorreo()\n</code></pre>"},{"location":"unit2/solid/#inversion-de-dependencia","title":"\u2705 Inversi\u00f3n de dependencia","text":"<pre><code>class CanalNotificacion:\n    def enviar(self, mensaje):\n        pass\n\nclass ServicioCorreo(CanalNotificacion):\n    def enviar(self, mensaje):\n        print(\"Correo:\", mensaje)\n\nclass Notificador:\n    def __init__(self, canal: CanalNotificacion):\n        self.canal = canal\n</code></pre> <p>Esto permite inyectar diferentes canales sin cambiar la clase <code>Notificador</code>.</p>"},{"location":"unit2/solid/#buenas-practicas-al-aplicar-solid","title":"Buenas pr\u00e1cticas al aplicar SOLID","text":"<p>\u2705 Refactoriza clases grandes en responsabilidades m\u00e1s peque\u00f1as \u2705 Usa composici\u00f3n y estrategias para evitar condicionales \u2705 Evita herencias innecesarias: prefiere interfaces y protocolos (composici\u00f3n &gt; herencia) \u2705 A\u00f1ade tests para validar comportamiento antes y despu\u00e9s de aplicar SOLID \u2705 En Python 3.8+, puedes usar <code>Protocol</code> de <code>typing</code> como forma ligera de interfaces</p>"},{"location":"unit2/solid/#errores-comunes","title":"Errores comunes","text":"<p>\u274c Aplicar todos los principios de forma r\u00edgida desde el d\u00eda uno \u274c Crear clases o jerarqu\u00edas complejas sin necesidad real \u274c No validar si la refactorizaci\u00f3n realmente mejora el dise\u00f1o \u274c Confundir \"extensibilidad\" con \"generalizaci\u00f3n excesiva\"</p>"},{"location":"unit2/solid/#recursos-recomendados","title":"Recursos recomendados","text":"<ul> <li>\ud83d\udcd8 The Principles of OOP \u2013 SOLID</li> <li>\ud83d\udcda Clean Architecture \u2013 Robert C. Martin</li> <li>\ud83e\uddf0 Design Patterns in Python</li> <li>\ud83d\udcd7 Real Python \u2013 SOLID principles</li> </ul>"},{"location":"unit2/solid/#conclusion","title":"Conclusi\u00f3n","text":"<p>Aplicar los principios SOLID en Python permite dise\u00f1ar software m\u00e1s robusto, flexible y mantenible. No se trata de seguir reglas por seguirlas, sino de tener criterios s\u00f3lidos para escribir clases y estructuras que puedan adaptarse a cambios con el menor impacto posible.</p> <p>Piensa en SOLID como una br\u00fajula para el dise\u00f1o profesional: no dicta el camino exacto, pero te ayuda a evitar muchos errores comunes.</p>"},{"location":"unit2/structure/","title":"Estructura de Proyectos","text":""},{"location":"unit2/structure/#introduccion","title":"Introducci\u00f3n","text":"<p>A medida que los proyectos crecen, la forma en que organizamos archivos, m\u00f3dulos y paquetes se vuelve tan importante como el propio c\u00f3digo. Una estructura de proyecto clara y coherente facilita el mantenimiento, la colaboraci\u00f3n en equipo y la escalabilidad.</p> <p>Este cap\u00edtulo explora buenas pr\u00e1cticas de organizaci\u00f3n de proyectos Python, estructuras recomendadas y errores comunes a evitar.</p>"},{"location":"unit2/structure/#por-que-importa-la-estructura","title":"\u00bfPor qu\u00e9 importa la estructura?","text":"<ul> <li>\ud83e\udde0 Facilita la comprensi\u00f3n del proyecto por nuevos integrantes.</li> <li>\ud83d\udd0d Mejora la navegaci\u00f3n y la b\u00fasqueda de m\u00f3dulos espec\u00edficos.</li> <li>\ud83d\udee0\ufe0f Permite integrar herramientas de testing, linting, documentaci\u00f3n y CI/CD de forma sencilla.</li> <li>\ud83d\ude80 Prepara el proyecto para distribuci\u00f3n, empaquetado o despliegue.</li> </ul>"},{"location":"unit2/structure/#estructura-minima-recomendada","title":"Estructura m\u00ednima recomendada","text":"<p>Un esquema b\u00e1sico y profesional de proyecto Python es:</p> <pre><code>mi_proyecto/\n\u2502\n\u251c\u2500\u2500 src/                  # C\u00f3digo fuente principal\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 main.py\n\u2502   \u2514\u2500\u2500 modulo/\n\u2502       \u251c\u2500\u2500 __init__.py\n\u2502       \u2514\u2500\u2500 operaciones.py\n\u2502\n\u251c\u2500\u2500 tests/                # Pruebas automatizadas\n\u2502   \u2514\u2500\u2500 test_operaciones.py\n\u2502\n\u251c\u2500\u2500 README.md             # Documentaci\u00f3n inicial\n\u251c\u2500\u2500 requirements.txt      # Dependencias del proyecto\n\u251c\u2500\u2500 pyproject.toml        # Configuraci\u00f3n del proyecto (est\u00e1ndar moderno)\n\u2514\u2500\u2500 .gitignore            # Exclusiones de control de versiones\n</code></pre>"},{"location":"unit2/structure/#detalle-de-carpetas-y-archivos","title":"Detalle de carpetas y archivos","text":"Componente Prop\u00f3sito <code>src/</code> C\u00f3digo fuente real del proyecto. <code>tests/</code> C\u00f3digo de pruebas unitarias y de integraci\u00f3n. <code>README.md</code> Instrucciones b\u00e1sicas para usuarios y colaboradores. <code>requirements.txt</code> Listado de dependencias (usado por <code>pip</code>). <code>pyproject.toml</code> Configuraci\u00f3n de herramientas como linters, formatters y build. <code>.gitignore</code> Archivos/carpetas que no deben ser versionados."},{"location":"unit2/structure/#organizacion-dentro-de-src","title":"Organizaci\u00f3n dentro de <code>src/</code>","text":"<p>A medida que crece el proyecto, dentro de <code>src/</code> es buena pr\u00e1ctica agrupar el c\u00f3digo en m\u00f3dulos l\u00f3gicos:</p> <pre><code>src/\n\u2502\n\u251c\u2500\u2500 app.py              # Punto de entrada principal\n\u251c\u2500\u2500 services/           # L\u00f3gica de negocio (servicios)\n\u251c\u2500\u2500 models/             # Modelos de datos\n\u251c\u2500\u2500 utils/              # Utilidades auxiliares\n\u2514\u2500\u2500 config/             # Configuraci\u00f3n y constantes\n</code></pre> <p>Cada carpeta deber\u00eda tener un <code>__init__.py</code> (puede estar vac\u00edo) para indicar que es un paquete de Python.</p>"},{"location":"unit2/structure/#por-que-usar-carpeta-src","title":"\u00bfPor qu\u00e9 usar carpeta <code>src/</code>?","text":"<ul> <li>Evita problemas de importaciones accidentales al testear.</li> <li>Separa claramente el c\u00f3digo fuente del resto del proyecto.</li> <li>Mejora la compatibilidad con herramientas modernas (Poetry, Hatch, etc.).</li> </ul> <p>\ud83e\udde0 Sin <code>src/</code>, a veces los tests funcionan \"por accidente\" porque Python encuentra el m\u00f3dulo en el mismo nivel. Con <code>src/</code>, solo encuentran los m\u00f3dulos que realmente instalaste o configuraste.</p>"},{"location":"unit2/structure/#recomendaciones-adicionales","title":"Recomendaciones adicionales","text":"<p>\u2705 Usa nombres de carpetas en min\u00fascula y snake_case (<code>utils/</code>, <code>services/</code>) \u2705 Agrupa funciones/m\u00e9todos relacionados en un mismo m\u00f3dulo \u2705 Prefiere m\u00faltiples m\u00f3dulos peque\u00f1os sobre uno monol\u00edtico gigante \u2705 Agrega un <code>README.md</code> m\u00ednimo tambi\u00e9n dentro de cada carpeta grande (<code>services/</code>, <code>models/</code>) explicando su rol \u2705 Mant\u00e9n los tests espejados respecto al c\u00f3digo fuente (ej: <code>src/modulo/operaciones.py</code> \u2192 <code>tests/modulo/test_operaciones.py</code>)</p>"},{"location":"unit2/structure/#errores-comunes","title":"Errores comunes","text":"<p>\u274c Mezclar scripts ejecutables y l\u00f3gica de negocio en un solo archivo \u274c Tener importaciones circulares entre m\u00f3dulos \u274c No separar configuraciones (<code>config/</code>) de l\u00f3gica (<code>services/</code>) \u274c No usar paquetes expl\u00edcitos (<code>__init__.py</code>) en proyectos grandes</p>"},{"location":"unit2/structure/#recursos-recomendados","title":"Recursos recomendados","text":"<ul> <li>\ud83d\udcd8 Python Application Layout \u2013 The Hitchhiker\u2019s Guide to Python</li> <li>\ud83d\udcda Best Practices for Structuring Python Projects</li> <li>\ud83e\uddf0 Modern Python Packaging with pyproject.toml</li> </ul>"},{"location":"unit2/structure/#conclusion","title":"Conclusi\u00f3n","text":"<p>Una buena estructura de proyecto no es un lujo: es una necesidad para cualquier aplicaci\u00f3n Python que aspire a crecer y mantenerse en el tiempo. Adoptar un esquema profesional desde el principio permite un desarrollo m\u00e1s \u00e1gil, colaborativo y organizado, haciendo que tu software sea m\u00e1s f\u00e1cil de testear, desplegar y evolucionar.</p>"},{"location":"unit3/","title":"\ud83c\udf3f Unidad 3: Control de Versiones","text":"<p>Aprende a trabajar colaborativamente y a gestionar el historial de tu c\u00f3digo con Git y GitHub.</p>"},{"location":"unit3/#contenidos","title":"Contenidos","text":"<ul> <li>Git: flujo de trabajo, ramas y commits</li> <li>Gitignore y limpieza del repositorio</li> <li>GitHub: colaboraci\u00f3n y gesti\u00f3n de repositorios</li> <li>Licencias de software</li> </ul>"},{"location":"unit3/#objetivos","title":"Objetivos","text":"<ul> <li>Usar Git de forma profesional.</li> <li>Configurar repositorios limpios y colaborativos.</li> <li>Entender el impacto legal de las licencias.</li> </ul>"},{"location":"unit3/#recursos","title":"Recursos","text":"<ul> <li>git.md</li> <li>gitignore.md</li> <li>github.md</li> <li>licensing.md</li> </ul>"},{"location":"unit4/","title":"\u2699\ufe0f Unidad 4: Entornos y Dependencias","text":"<p>Configuramos entornos de desarrollo reproducibles y aislados usando herramientas modernas.</p>"},{"location":"unit4/#contenidos","title":"Contenidos","text":"<ul> <li>Pyenv y Virtualenv</li> <li>Poetry: gesti\u00f3n de dependencias y publicaci\u00f3n</li> <li>uv: gestor r\u00e1pido de entornos</li> <li>Makefile: automatizaci\u00f3n de tareas comunes</li> </ul>"},{"location":"unit4/#objetivos","title":"Objetivos","text":"<ul> <li>Crear entornos aislados por proyecto.</li> <li>Gestionar dependencias de forma controlada.</li> <li>Automatizar flujos de trabajo con Makefile.</li> </ul>"},{"location":"unit4/#recursos","title":"Recursos","text":"<ul> <li>pyenv.md</li> <li>virtualenv.md</li> <li>poetry.md</li> <li>uv.md</li> <li>makefile.md</li> </ul>"},{"location":"unit5/","title":"\u2705 Unidad 5: Calidad de C\u00f3digo","text":"<p>Descubre c\u00f3mo mantener tu c\u00f3digo limpio, legible y libre de errores comunes.</p>"},{"location":"unit5/#contenidos","title":"Contenidos","text":"<ul> <li>Ruff: linter y formateador moderno</li> <li>Black: formateo autom\u00e1tico</li> <li>Mypy: an\u00e1lisis de tipado est\u00e1tico</li> <li>Pre-commit hooks</li> <li>Linters tradicionales (flake8, isort)</li> </ul>"},{"location":"unit5/#objetivos","title":"Objetivos","text":"<ul> <li>Automatizar el chequeo de estilo y errores.</li> <li>Mejorar la legibilidad del c\u00f3digo.</li> <li>Integrar validaciones en el flujo de desarrollo.</li> </ul>"},{"location":"unit5/#recursos","title":"Recursos","text":"<ul> <li>ruff.md</li> <li>black.md</li> <li>mypy.md</li> <li>others.md</li> <li>precommit.md</li> </ul>"},{"location":"unit6/","title":"\ud83e\uddea Unidad 6: Testing","text":"<p>Construimos software confiable mediante pruebas unitarias, de integraci\u00f3n y basadas en propiedades.</p>"},{"location":"unit6/#contenidos","title":"Contenidos","text":"<ul> <li>Introducci\u00f3n al testing</li> <li>Pytest: framework principal</li> <li>Coverage: cobertura de c\u00f3digo</li> <li>Mocking: simulaci\u00f3n de dependencias</li> <li>Hypothesis: testing basado en propiedades</li> </ul>"},{"location":"unit6/#objetivos","title":"Objetivos","text":"<ul> <li>Escribir pruebas automatizadas.</li> <li>Detectar errores antes de desplegar.</li> <li>Medir y mejorar la cobertura de tests.</li> </ul>"},{"location":"unit6/#recursos","title":"Recursos","text":"<ul> <li>intro.md</li> <li>pytest.md</li> <li>coverage.md</li> <li>mocking.md</li> <li>hypothesis.md</li> </ul>"},{"location":"unit7/","title":"\ud83d\udcd8 Unidad 7: Documentaci\u00f3n","text":"<p>Aprende a documentar tu c\u00f3digo y proyectos de forma clara y profesional.</p>"},{"location":"unit7/#contenidos","title":"Contenidos","text":"<ul> <li>Introducci\u00f3n a la documentaci\u00f3n t\u00e9cnica</li> <li>MkDocs: documentaci\u00f3n est\u00e1tica</li> <li>Tema Material para MkDocs</li> <li>Plugins \u00fatiles para mejorar la experiencia</li> </ul>"},{"location":"unit7/#objetivos","title":"Objetivos","text":"<ul> <li>Crear documentaci\u00f3n navegable.</li> <li>Automatizar la generaci\u00f3n de documentaci\u00f3n.</li> <li>Publicar sitios con documentaci\u00f3n t\u00e9cnica.</li> </ul>"},{"location":"unit7/#recursos","title":"Recursos","text":"<ul> <li>intro.md</li> <li>mkdocs.md</li> <li>mkdocs-material.md</li> <li>mkdocs-plugging.md</li> </ul>"},{"location":"unit8/","title":"\ud83c\udf81 Unidad 8: Extras","text":"<p>Recursos complementarios que enriquecen el proceso de desarrollo profesional.</p>"},{"location":"unit8/#contenidos","title":"Contenidos","text":"<ul> <li>Diagramas UML con PlantUML</li> <li>Visualizaci\u00f3n con <code>diagrams</code></li> <li>Notebooks interactivos para documentaci\u00f3n</li> </ul>"},{"location":"unit8/#objetivos","title":"Objetivos","text":"<ul> <li>Representar gr\u00e1ficamente la arquitectura del software.</li> <li>Explorar herramientas visuales en Python.</li> <li>Integrar notebooks en flujos t\u00e9cnicos.</li> </ul>"},{"location":"unit8/#recursos","title":"Recursos","text":"<ul> <li>plantuml.ipynb</li> <li>diagrams.ipynb</li> </ul>"}]}